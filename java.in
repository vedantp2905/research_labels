returnBuffer . append ( minParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . MAX ) ; 
returnBuffer . append ( maxParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . STEP_FACTOR ) ; 
returnBuffer . append ( stepFactorParam ) ; 
String prefix = ( prefixParam == null ) ? "" : prefixParam ; 
returnBuffer . append ( FieldMetaData . Decimal . PREFIX ) ; 
returnBuffer . append ( prefix ) ; 
return returnBuffer . toString ( ) ; 
} public User createUser ( User userParam ) 
if ( userParam != null && this . serviceTicket != null ) 
userParam . setServiceTicket ( this . serviceTicket ) ; 
return new User ( this . putJson ( 
userParam , WS . Path . User . Version1 . userCreate ( ) ) ) ; 
} public User updateUser ( User userParam ) 
return new User ( this . postJson ( 
userParam , WS . Path . User . Version1 . userUpdate ( ) ) ) ; 
} public User activateUser ( User userParam ) 
userParam , 
WS . Path . User . Version1 . userActivate ( ) ) ) ; 
} public User deActivateUser ( User userParam ) 
WS . Path . User . Version1 . userDeActivate ( ) ) ) ; 
} public User incrementInvalidLoginForUser ( User userParam ) 
WS . Path . User . Version1 . incrementInvalidLogin ( ) ) ) ; 
} public User changePasswordForLoggedInUser ( 
String existingPasswordParam , 
String newPasswordParam , 
String confirmNewPasswordParam ) { 
User toChangePasswordFor = new User ( ) ; 
toChangePasswordFor . setServiceTicket ( this . serviceTicket ) ; 
String existingPassword = 
existingPasswordParam == null ? UtilGlobal . EMPTY : existingPasswordParam ; 
String newPassword = 
newPasswordParam == null ? UtilGlobal . EMPTY : newPasswordParam ; 
String confirmNewPassword = 
confirmNewPasswordParam == null ? UtilGlobal . EMPTY : confirmNewPasswordParam ; 
JSONObject passwordClear = new JSONObject ( ) ; 
passwordClear . put ( "existing" , existingPassword ) ; 
passwordClear . put ( "new" , newPassword ) ; 
passwordClear . put ( "confirm_new" , confirmNewPassword ) ; 
toChangePasswordFor . setPasswordClear ( passwordClear . toString ( ) ) ; 
toChangePasswordFor , 
WS . Path . User . Version1 . changePassword ( ) ) ) ; 
} public User deleteUser ( 
User userToDeleteParam , 
boolean forcefullyDeleteParam ) 
if ( userToDeleteParam != null && this . serviceTicket != null ) 
userToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new User ( this . postJson ( userToDeleteParam , 
WS . Path . User . Version1 . userDelete ( forcefullyDeleteParam ) ) ) ; 
} public User getLoggedInUserInformation ( ) 
User userToGetInfoFor = new User ( ) ; 
if ( this . serviceTicket != null ) 
userToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
userToGetInfoFor , 
WS . Path . User . Version1 . userInformation ( ) ) ) ; 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , 
FluidClientException . ErrorCode . JSON_PARSING ) ; 
} public User getUserWhereUsername ( String usernameParam ) 
userToGetInfoFor . setUsername ( usernameParam ) ; 
userToGetInfoFor , WS . Path . User . Version1 . getByUsername ( ) ) ) ; 
} public User getUserWhereEmail ( String emailAddressParam ) 
if ( emailAddressParam != null ) 
List < String > emailAdd = new ArrayList ( ) ; 
emailAdd . add ( emailAddressParam ) ; 
userToGetInfoFor . setEmailAddresses ( emailAdd ) ; 
userToGetInfoFor , WS . Path . User . Version1 . getByEmail ( ) ) ) ; 
} public User getUserById ( Long userIdParam ) 
userToGetInfoFor . setId ( userIdParam ) ; 
userToGetInfoFor , WS . Path . User . Version1 . getById ( ) ) ) ; 
} public UserListing getAllUsers ( ) 
UserListing userToGetInfoFor = new UserListing ( ) ; 
return new UserListing ( this . postJson ( 
WS . Path . User . Version1 . getAllUsers ( ) ) ) ; 
} public UserListing getAllUsersByJobView ( JobView jobViewParam ) { 
if ( this . serviceTicket != null && jobViewParam != null ) { 
jobViewParam . setServiceTicket ( this . serviceTicket ) ; 
jobViewParam , 
WS . Path . User . Version1 . getAllUsersByJobView ( ) ) ) ; 
} catch ( JSONException jsonExcept ) { 
} public UserListing getAllUsersByRole ( Role roleParam ) { 
if ( this . serviceTicket != null && roleParam != null ) { 
roleParam . setServiceTicket ( this . serviceTicket ) ; 
roleParam , WS . Path . User . Version1 . getAllUsersByRole ( ) ) ) ; 
} public UserListing getAllUsersWhereLoggedInSince ( Date loggedInSinceParam ) { 
User userToPost = new User ( ) ; 
userToPost . setLoggedInDateTime ( loggedInSinceParam ) ; 
userToPost . setServiceTicket ( this . serviceTicket ) ; 
userToPost , WS . Path . User . Version1 . getAllUsersWhereLoggedInSince ( ) ) ) ; 
} public UserFieldListing getAllUserFieldValuesByUser ( User userParam ) 
if ( userParam == null ) 
return new UserFieldListing ( this . postJson ( 
WS . Path . User . Version1 . getUserFieldValuesByUser ( ) ) ) ; 
} public byte [ ] getGravatarForEmail ( 
String emailAddressParam , 
int sizeParam ) 
JSONObject gravatarJSONObj = 
this . getJson ( 
WS . Path . User . Version1 . getGravatarByEmail ( 
emailAddressParam , sizeParam ) ) ; 
String base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , "" ) ; 
if ( base64Text == null || base64Text . isEmpty ( ) ) 
return UtilGlobal . decodeBase64 ( base64Text ) ; 
jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; 
catch ( UnsupportedEncodingException unsEncExcept ) { 
throw new FluidClientException ( unsEncExcept . getMessage ( ) , 
unsEncExcept , FluidClientException . ErrorCode . IO_ERROR ) ; 
} public byte [ ] getGravatarForUser ( User userParam , int sizeParam ) 
JSONObject gravatarJSONObj = this . postJson ( 
WS . Path . User . Version1 . getGravatarByUser ( sizeParam ) ) ; 
} @ XmlTransient 
public boolean doesUserHaveAccessToRole ( Role roleParam ) 
if ( roleParam == null ) 
return this . doesUserHaveAccessToRole ( roleParam . getName ( ) ) ; 
public boolean doesUserHaveAccessToRole ( String roleNameParam ) 
if ( roleNameParam == null || roleNameParam . trim ( ) . isEmpty ( ) ) 
if ( this . getRoles ( ) == null || this . getRoles ( ) . isEmpty ( ) ) 
String roleNameParamLower = roleNameParam . trim ( ) . toLowerCase ( ) ; 
for ( Role roleAtIndex : this . getRoles ( ) ) 
if ( roleAtIndex . getName ( ) == null || 
roleAtIndex . getName ( ) . trim ( ) . isEmpty ( ) ) 
String iterRoleNameLower = roleAtIndex . getName ( ) . trim ( ) . toLowerCase ( ) ; 
if ( roleNameParamLower . equals ( iterRoleNameLower ) ) 
@ XmlTransient 
returnVal . put ( JSONMapping . ACTIVE , this . isActive ( ) ) ; 
returnVal . put ( JSONMapping . INVALID_LOGIN_COUNT , 
this . getInvalidLoginCount ( ) ) ; 
if ( this . getUsername ( ) != null ) 
returnVal . put ( JSONMapping . USERNAME , this . getUsername ( ) ) ; 
if ( this . getPasswordSha256 ( ) != null ) 
returnVal . put ( JSONMapping . PASSWORD_SHA_256 , this . getPasswordSha256 ( ) ) ; 
if ( this . getPasswordClear ( ) != null ) 
returnVal . put ( JSONMapping . PASSWORD_CLEAR , this . getPasswordClear ( ) ) ; 
returnVal . put ( User . JSONMapping . DATE_CREATED , 
this . getDateAsLongFromJson ( this . getDateCreated ( ) ) ) ; 
returnVal . put ( User . JSONMapping . DATE_LAST_UPDATED , 
this . getDateAsLongFromJson ( this . getDateLastUpdated ( ) ) ) ; 
if ( this . getPasswordChangedAt ( ) != null ) 
returnVal . put ( JSONMapping . PASSWORD_CHANGED_AT , 
this . getDateAsLongFromJson ( this . getPasswordChangedAt ( ) ) ) ; 
if ( this . getLoggedInDateTime ( ) != null ) 
returnVal . put ( JSONMapping . LOGGED_IN_DATE_TIME , 
this . getDateAsLongFromJson ( this . getLoggedInDateTime ( ) ) ) ; 
if ( this . getSalt ( ) != null ) 
returnVal . put ( JSONMapping . SALT , this . getSalt ( ) ) ; 
if ( this . getTimezone ( ) != null ) 
returnVal . put ( JSONMapping . TIMEZONE , 
this . getTimezone ( ) . doubleValue ( ) ) ; 
if ( this . getDateFormat ( ) != null ) 
returnVal . put ( JSONMapping . DATE_FORMAT , this . getDateFormat ( ) ) ; 
if ( this . getTimeFormat ( ) != null ) 
returnVal . put ( JSONMapping . TIME_FORMAT , this . getTimeFormat ( ) ) ; 
if ( this . getLocale ( ) != null ) { 
returnVal . put ( JSONMapping . LOCALE , this . getLocale ( ) ) ; 
returnVal . put ( JSONMapping . EMAIL_USER_NOTIFICATION , this . isEmailUserNotification ( ) ) ; 
if ( this . getRoles ( ) != null && ! this . getRoles ( ) . isEmpty ( ) ) 
JSONArray rolesArr = new JSONArray ( ) ; 
for ( Role toAdd : this . getRoles ( ) ) 
rolesArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLES , rolesArr ) ; 
if ( this . getEmailAddresses ( ) != null && 
! this . getEmailAddresses ( ) . isEmpty ( ) ) 
JSONArray emailArr = new JSONArray ( ) ; 
for ( String toAdd : this . getEmailAddresses ( ) ) 
emailArr . put ( toAdd ) ; 
returnVal . put ( JSONMapping . EMAIL_ADDRESSES , emailArr ) ; 
JSONArray userFieldsArr = new JSONArray ( ) ; 
for ( Field toAdd : this . getUserFields ( ) ) 
userFieldsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . USER_FIELDS , userFieldsArr ) ; 
public Field getField ( String fieldNameParam ) { 
if ( fieldNameParam == null || fieldNameParam . trim ( ) . isEmpty ( ) ) { 
if ( this . userFields == null || this . userFields . isEmpty ( ) ) { 
String fieldNameParamLower = fieldNameParam . trim ( ) . toLowerCase ( ) ; 
for ( Field field : this . userFields ) { 
String fieldName = field . getFieldName ( ) ; 
if ( fieldName == null || fieldName . trim ( ) . isEmpty ( ) ) { 
String fieldNameLower = fieldName . trim ( ) . toLowerCase ( ) ; 
if ( fieldNameParamLower . equals ( fieldNameLower ) ) { 
public MultiChoice getFieldValueAsMultiChoice ( String fieldNameParam ) { 
Field fieldReturn = this . getField ( fieldNameParam ) ; 
return ( fieldReturn == null ) ? null : fieldReturn . getFieldValueAsMultiChoice ( ) ; 
if ( this . getJobView ( ) != null ) 
returnVal . put ( JSONMapping . JOB_VIEW , 
this . getJobView ( ) . toJsonObject ( ) ) ; 
if ( this . getRole ( ) != null ) 
returnVal . put ( JSONMapping . ROLE , 
this . getRole ( ) . toJsonObject ( ) ) ; 
public String getFieldValueAsString ( ) { 
Object returnObj = this . getFieldValue ( ) ; 
return ( returnObj == null ) ? null : returnObj . toString ( ) ; 
public Double getFieldValueAsDouble ( ) { 
Object obj = this . getFieldValue ( ) ; 
if ( obj instanceof Double ) { 
return ( Double ) obj ; 
if ( obj instanceof Number ) { 
return ( ( Number ) obj ) . doubleValue ( ) ; 
public Long getFieldValueAsLong ( ) { 
if ( obj instanceof Long ) { 
return ( Long ) obj ; 
return ( ( Number ) obj ) . longValue ( ) ; 
public Integer getFieldValueAsInteger ( ) { 
if ( obj instanceof Integer ) { 
return ( Integer ) obj ; 
return ( ( Number ) obj ) . intValue ( ) ; 
public Number getFieldValueAsNumber ( ) { 
return ( Number ) obj ; 
public Boolean getFieldValueAsBoolean ( ) { 
if ( obj instanceof Boolean ) { 
return ( Boolean ) obj ; 
public Date getFieldValueAsDate ( ) { 
if ( obj instanceof Date ) { 
return ( Date ) obj ; 
else if ( obj instanceof Long ) { 
Long longValue = ( Long ) obj ; 
if ( longValue . longValue ( ) > 0 ) { 
return new Date ( longValue . longValue ( ) ) ; 
public MultiChoice getFieldValueAsMultiChoice ( ) { 
if ( obj instanceof MultiChoice ) { 
return ( MultiChoice ) obj ; 
public TableField getFieldValueAsTableField ( ) { 
if ( obj instanceof TableField ) { 
return ( TableField ) obj ; 
} public void setFieldValue ( Object fieldValueParam ) { 
this . fieldValue = fieldValueParam ; 
if ( this . getFieldType ( ) == null && fieldValueParam != null ) 
if ( fieldValueParam instanceof Date ) 
this . setTypeAsEnum ( Type . DateTime ) ; 
else if ( fieldValueParam instanceof Number ) 
this . setTypeAsEnum ( Type . Decimal ) ; 
else if ( fieldValueParam instanceof MultiChoice ) 
this . setTypeAsEnum ( Type . MultipleChoice ) ; 
else if ( fieldValueParam instanceof TableField ) 
this . setTypeAsEnum ( Type . Table ) ; 
else if ( fieldValueParam instanceof String ) 
this . setTypeAsEnum ( Type . Text ) ; 
else if ( fieldValueParam instanceof Boolean ) 
this . setTypeAsEnum ( Type . TrueFalse ) ; 
public void setTypeAsEnum ( Type typeParam ) { 
if ( typeParam == null ) 
this . fieldType = null ; 
this . fieldType = typeParam . name ( ) ; 
public Type getTypeAsEnum ( ) 
if ( this . getFieldType ( ) == null || this . getFieldType ( ) . trim ( ) . isEmpty ( ) ) 
return Type . valueOf ( this . getFieldType ( ) ) ; 
if ( this . getFieldName ( ) != null ) 
returnVal . put ( JSONMapping . FIELD_NAME , this . getFieldName ( ) ) ; 
if ( this . getFieldDescription ( ) != null ) 
returnVal . put ( JSONMapping . FIELD_DESCRIPTION , this . getFieldDescription ( ) ) ; 
if ( this . getFieldValue ( ) != null ) 
if ( this . getFieldValue ( ) instanceof String ) 
returnVal . put ( JSONMapping . FIELD_VALUE , this . getFieldValue ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof Number ) 
returnVal . put ( JSONMapping . FIELD_VALUE , 
( ( Number ) this . getFieldValue ( ) ) . doubleValue ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof Boolean ) 
( Boolean ) this . getFieldValue ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof Date ) 
this . getDateAsLongFromJson ( ( Date ) this . getFieldValue ( ) ) ) ; 
else if ( this . getFieldValue ( ) instanceof MultiChoice ) 
( ( MultiChoice ) this . getFieldValue ( ) ) . toJsonObject ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof TableField ) 
( ( TableField ) this . getFieldValue ( ) ) . toJsonObject ( ) ) ; 
if ( this . getFieldType ( ) != null ) 
returnVal . put ( JSONMapping . FIELD_TYPE , this . getFieldType ( ) ) ; 
if ( this . getTypeMetaData ( ) != null ) 
returnVal . put ( JSONMapping . TYPE_META_DATA , this . getTypeMetaData ( ) ) ; 
public JSONObject toJsonMappingForElasticSearch ( ) throws JSONException { 
String fieldNameUpperCamel = this . getFieldNameAsUpperCamel ( ) ; 
if ( fieldNameUpperCamel == null ) 
String elasticType = this . getElasticSearchFieldType ( ) ; 
if ( elasticType == null ) 
returnVal . put ( JSONMapping . Elastic . MAPPING_ONLY_TYPE , elasticType ) ; 
public JSONObject toJsonForElasticSearch ( ) throws JSONException { 
if ( ! this . doesFieldQualifyForElasticSearchInsert ( ) ) 
String fieldIdAsString = this . getFieldNameAsUpperCamel ( ) ; 
Object fieldValue = this . getFieldValue ( ) ; 
if ( fieldValue instanceof TableField ) 
TableField tableField = ( TableField ) this . getFieldValue ( ) ; 
if ( tableField . getTableRecords ( ) != null && 
! tableField . getTableRecords ( ) . isEmpty ( ) ) 
JSONArray array = new JSONArray ( ) ; 
for ( Form record : tableField . getTableRecords ( ) ) 
if ( record . getId ( ) == null ) 
array . put ( record . getId ( ) ) ; 
returnVal . put ( fieldIdAsString , array ) ; 
else if ( fieldValue instanceof MultiChoice ) 
MultiChoice multiChoice = ( MultiChoice ) this . getFieldValue ( ) ; 
if ( multiChoice . getSelectedMultiChoices ( ) != null && 
! multiChoice . getSelectedMultiChoices ( ) . isEmpty ( ) ) 
for ( String selectedChoice : multiChoice . getSelectedMultiChoices ( ) ) 
Long selectedChoiceAsLong = null ; 
if ( ! selectedChoice . isEmpty ( ) && 
Character . isDigit ( selectedChoice . charAt ( 0 ) ) ) 
selectedChoiceAsLong = Long . parseLong ( selectedChoice ) ; 
catch ( NumberFormatException nfe ) 
selectedChoiceAsLong = null ; 
if ( selectedChoiceAsLong == null ) 
array . put ( selectedChoice ) ; 
array . put ( selectedChoiceAsLong . longValue ( ) ) ; 
else if ( ( fieldValue instanceof Number || fieldValue instanceof Boolean ) || 
fieldValue instanceof String ) 
if ( ( fieldValue instanceof String ) && LATITUDE_AND_LONGITUDE . equals ( this . getTypeMetaData ( ) ) ) { 
String formFieldValueStr = fieldValue . toString ( ) ; 
UtilGlobal utilGlobal = new UtilGlobal ( ) ; 
String latitude = utilGlobal . getLatitudeFromFluidText ( formFieldValueStr ) ; 
String longitude = utilGlobal . getLongitudeFromFluidText ( formFieldValueStr ) ; 
fieldValue = ( latitude . concat ( UtilGlobal . COMMA ) . concat ( longitude ) ) ; 
returnVal . put ( fieldIdAsString , fieldValue ) ; 
else if ( fieldValue instanceof Date ) 
returnVal . put ( fieldIdAsString , ( ( Date ) fieldValue ) . getTime ( ) ) ; 
throw new FluidElasticSearchException ( 
public Field populateFromElasticSearchJson ( 
JSONObject jsonObjectParam 
) throws JSONException { 
if ( this . getFieldNameAsUpperCamel ( ) == null ) { 
if ( jsonObjectParam . isNull ( fieldIdAsString ) ) { 
Field . Type type ; 
if ( ( type = this . getTypeAsEnum ( ) ) == null ) { 
Object formFieldValue = jsonObjectParam . get ( fieldIdAsString ) ; 
Field fieldToAdd = null ; 
case DateTime : 
if ( formFieldValue instanceof Long ) { 
fieldToAdd = new Field ( 
this . getId ( ) , 
this . getFieldName ( ) , 
new Date ( ( ( Long ) formFieldValue ) . longValue ( ) ) , 
type ) ; 
case Decimal : 
if ( formFieldValue instanceof Number ) { 
( ( Number ) formFieldValue ) . doubleValue ( ) , 
case MultipleChoice : 
if ( formFieldValue instanceof JSONArray ) { 
JSONArray casted = ( JSONArray ) formFieldValue ; 
List < String > selectedChoices = new ArrayList ( ) ; 
for ( int index = 0 ; index < casted . length ( ) ; index ++ ) { 
selectedChoices . add ( casted . get ( index ) . toString ( ) ) ; 
if ( selectedChoices . isEmpty ( ) ) { 
MultiChoice multiChoiceToSet = new MultiChoice ( selectedChoices ) ; 
multiChoiceToSet , 
case Table : 
List < Form > tableRecords = new ArrayList ( ) ; 
Object obAtIndex = casted . get ( index ) ; 
if ( obAtIndex instanceof Number ) { 
tableRecords . add ( new Form ( ( ( Number ) obAtIndex ) . longValue ( ) ) ) ; 
else if ( formFieldValue instanceof Number ) { 
tableRecords . add ( new Form ( ( ( Number ) formFieldValue ) . longValue ( ) ) ) ; 
if ( tableRecords . isEmpty ( ) ) { 
new TableField ( tableRecords ) , 
case Text : 
case ParagraphText : 
if ( formFieldValue instanceof String ) { 
if ( LATITUDE_AND_LONGITUDE . equals ( this . getTypeMetaData ( ) ) ) { 
String formFieldValueStr = formFieldValue . toString ( ) ; 
double latitude = utilGlobal . getLatitudeFromElasticSearchText ( formFieldValueStr ) ; 
double longitude = utilGlobal . getLongitudeFromElasticSearchText ( formFieldValueStr ) ; 
String newFieldVal = 
( latitude + UtilGlobal . PIPE + longitude + UtilGlobal . PIPE ) ; 
newFieldVal , 
formFieldValue . toString ( ) , 
case TrueFalse : 
if ( formFieldValue instanceof Boolean ) { 
formFieldValue , 
return fieldToAdd ; 
public void populateFromElasticSearchJson ( 
JSONObject jsonObjectParam , List < Field > formFieldsParam ) throws JSONException { 
public String getElasticSearchFieldType ( ) 
Type fieldType = this . getTypeAsEnum ( ) ; 
if ( fieldType == null ) 
switch ( fieldType ) 
return ElasticSearchType . TEXT ; 
String metaData = this . getTypeMetaData ( ) ; 
if ( metaData == null || metaData . isEmpty ( ) ) 
if ( LATITUDE_AND_LONGITUDE . equals ( metaData ) ) 
return ElasticSearchType . GEO_POINT ; 
return ElasticSearchType . BOOLEAN ; 
return ElasticSearchType . DATE ; 
return ElasticSearchType . DOUBLE ; 
return ElasticSearchType . KEYWORD ; 
} private boolean doesFieldQualifyForElasticSearchInsert ( ) 
Field . Type fieldType ; 
if ( ( ( this . getFieldValue ( ) ) == null ) || 
( ( fieldType = this . getTypeAsEnum ( ) ) == null ) ) 
if ( this . getFieldName ( ) == null || 
this . getFieldName ( ) . trim ( ) . isEmpty ( ) ) 
switch ( fieldType ) { 
case TextEncrypted : 
if ( this . getClientId ( ) != null ) 
returnVal . put ( JSONMapping . CLIENT_ID , this . getClientId ( ) ) ; 
if ( this . getClientSecret ( ) != null ) 
returnVal . put ( JSONMapping . CLIENT_SECRET , this . getClientSecret ( ) ) ; 
if ( this . getCode ( ) != null ) 
returnVal . put ( JSONMapping . CODE , this . getCode ( ) ) ; 
if ( this . getGrantType ( ) != null ) 
returnVal . put ( JSONMapping . GRANT_TYPE , this . getGrantType ( ) ) ; 
if ( this . getRedirectUri ( ) != null ) 
returnVal . put ( JSONMapping . REDIRECT_URI , this . getRedirectUri ( ) ) ; 
} public void setStepProperty ( 
String nameParam , String valueParam ) 
if ( this . getStepProperties ( ) == null ) 
this . setStepProperties ( new ArrayList ( ) ) ; 
if ( nameParam == null || nameParam . trim ( ) . isEmpty ( ) ) 
if ( valueParam . trim ( ) . isEmpty ( ) ) 
String paramLower = nameParam . toLowerCase ( ) ; 
for ( StepProperty existingProp : this . getStepProperties ( ) ) 
if ( existingProp . getName ( ) . toLowerCase ( ) . equals ( paramLower ) ) 
existingProp . setValue ( valueParam ) ; 
this . getStepProperties ( ) . add ( new StepProperty ( nameParam , valueParam ) ) ; 
} public String getStepProperty ( String nameParam ) 
if ( this . getStepProperties ( ) == null || this . getStepProperties ( ) . isEmpty ( ) ) 
for ( StepProperty stepProperty : this . getStepProperties ( ) ) 
if ( stepProperty . getName ( ) . toLowerCase ( ) . equals ( paramLower ) ) 
return stepProperty . getValue ( ) ; 
returnVal . put ( JSONMapping . DATE_CREATED , 
returnVal . put ( JSONMapping . DATE_LAST_UPDATED , 
if ( this . getFlow ( ) != null ) 
returnVal . put ( JSONMapping . FLOW , 
this . getFlow ( ) . toJsonObject ( ) ) ; 
if ( this . getFlowStepType ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STEP_TYPE , this . getFlowStepType ( ) ) ; 
if ( this . getFlowStepParentId ( ) != null ) 
returnVal . put ( 
JSONMapping . FLOW_STEP_PARENT_ID , this . getFlowStepParentId ( ) ) ; 
if ( this . getEntryRules ( ) != null && ! this . getEntryRules ( ) . isEmpty ( ) ) 
for ( FlowStepRule rule : this . getEntryRules ( ) ) 
returnVal . put ( JSONMapping . ENTRY_RULES , jsonArray ) ; 
if ( this . getExitRules ( ) != null && ! this . getExitRules ( ) . isEmpty ( ) ) 
for ( FlowStepRule rule : this . getExitRules ( ) ) 
returnVal . put ( JSONMapping . EXIT_RULES , jsonArray ) ; 
if ( this . getViewRules ( ) != null && ! this . getViewRules ( ) . isEmpty ( ) ) 
for ( FlowStepRule rule : this . getViewRules ( ) ) 
returnVal . put ( JSONMapping . VIEW_RULES , jsonArray ) ; 
if ( this . getStepProperties ( ) != null && ! this . getStepProperties ( ) . isEmpty ( ) ) 
jsonArray . put ( stepProperty . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . STEP_PROPERTIES , jsonArray ) ; 
if ( this . getUsername ( ) != null ) { 
if ( this . getLifetime ( ) != null ) { 
returnVal . put ( JSONMapping . LIFETIME , this . getLifetime ( ) ) ; 
} public FlowStep createFlowStep ( FlowStep flowStepParam ) 
if ( flowStepParam != null && this . serviceTicket != null ) 
flowStepParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . putJson ( 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepCreate ( ) ) ) ; 
} public FlowStep updateFlowStep ( FlowStep flowStepParam ) 
return new FlowStep ( this . postJson ( 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepUpdate ( ) ) ) ; 
} public FlowStep getFlowStepById ( 
Long flowStepIdParam , String flowStepTypeParam ) 
FlowStep flowStep = new FlowStep ( flowStepIdParam ) ; 
flowStep . setFlowStepType ( flowStepTypeParam ) ; 
flowStep . setServiceTicket ( this . serviceTicket ) ; 
flowStep , WS . Path . FlowStep . Version1 . getById ( ) ) ) ; 
} public FlowStep getFlowStepByStep ( FlowStep flowStepParam ) 
if ( this . serviceTicket != null && flowStepParam != null ) 
flowStepParam , WS . Path . FlowStep . Version1 . getByStep ( ) ) ) ; 
} public JobViewListing getJobViewsByStepName ( 
String flowStepNameParam , Flow flowParam ) 
FlowStep step = new FlowStep ( ) ; 
step . setName ( flowStepNameParam ) ; 
step . setFlow ( flowParam ) ; 
return this . getJobViewsByStep ( step ) ; 
} public JobView getStandardJobViewBy ( 
String flowNameParam , 
String flowStepNameParam , 
String flowViewNameParam ) 
if ( flowNameParam == null || 
flowNameParam . trim ( ) . isEmpty ( ) ) 
throw new FluidClientException ( 
FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( flowStepNameParam == null || 
flowStepNameParam . trim ( ) . isEmpty ( ) ) 
if ( flowViewNameParam == null || 
flowViewNameParam . trim ( ) . isEmpty ( ) ) 
JobViewListing jobViewListing = this . getJobViewsByStepName ( 
flowStepNameParam , new Flow ( flowNameParam ) ) ; 
JobView returnVal = null ; 
if ( jobViewListing . getListingCount ( ) . intValue ( ) > 1 ) 
for ( JobView jobView : jobViewListing . getListing ( ) ) 
if ( ViewType . STANDARD . equals ( jobView . getViewType ( ) ) && 
jobView . getViewName ( ) . equalsIgnoreCase ( flowViewNameParam ) ) 
returnVal = jobView ; 
if ( returnVal == null ) 
flowViewNameParam + "'." , 
FluidClientException . ErrorCode . NO_RESULT ) ; 
} public JobViewListing getJobViewsByStep ( FlowStep flowStepParam ) 
return new JobViewListing ( this . postJson ( 
flowStepParam , WS . Path . FlowStep . Version1 . getAllViewsByStep ( ) ) ) ; 
} public JobViewListing getJobViewsByLoggedInUser ( ) 
FlowStep flowStep = new FlowStep ( ) ; 
flowStep , WS . Path . FlowStep . Version1 . getAllViewsByLoggedInUser ( ) ) ) ; 
} public JobViewListing getJobViewsByUser ( User userParam ) 
if ( this . serviceTicket != null && userParam != null ) 
userParam , WS . Path . FlowStep . Version1 . getAllViewsByUser ( ) ) ) ; 
} public JobViewListing getJobViewsByFlow ( Flow flowParam ) 
if ( this . serviceTicket != null && flowParam != null ) 
flowParam . setServiceTicket ( this . serviceTicket ) ; 
flowParam , WS . Path . FlowStep . Version1 . getAllViewsByFlow ( ) ) ) ; 
} public FlowStepListing getStepsByFlow ( Flow flowParam ) 
return new FlowStepListing ( this . postJson ( 
flowParam , WS . Path . FlowStep . Version1 . getAllStepsByFlow ( ) ) ) ; 
} public FlowStep deleteFlowStep ( FlowStep flowStepParam ) 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( ) ) ) ; 
} public FlowStep forceDeleteFlowStep ( FlowStep flowStepParam ) 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( true ) ) ) ; 
} public final List < ElasticTypeAndId > searchAndConvertHitsToIdsOnly ( 
QueryBuilder qbParam , 
String indexParam , 
int offsetParam , 
int limitParam , 
Long ... formTypesParam ) { 
SearchHits searchHits = this . searchWithHits ( 
qbParam , 
indexParam , 
offsetParam , 
limitParam , 
formTypesParam ) ; 
List < ElasticTypeAndId > returnVal = null ; 
long totalHits ; 
if ( searchHits != null && ( totalHits = searchHits . getTotalHits ( ) ) > 0 ) { 
returnVal = new ArrayList ( ) ; 
if ( ( searchHits . getHits ( ) . length != totalHits ) && 
( searchHits . getHits ( ) . length != limitParam ) ) 
searchHits . getHits ( ) . length + "'." ) ; 
long iterationMax = totalHits ; 
if ( limitParam > 0 && totalHits > limitParam ) { 
iterationMax = limitParam ; 
for ( int index = 0 ; index < iterationMax ; index ++ ) { 
SearchHit searchHit = searchHits . getAt ( index ) ; 
String idAsString ; 
if ( ( idAsString = searchHit . getId ( ) ) == null ) { 
returnVal . add ( new ElasticTypeAndId ( 
this . toLongSafe ( idAsString ) , 
searchHit . getType ( ) ) ) ; 
} public final SearchHits searchWithHits ( 
boolean withNoFieldsParam , 
Long ... formTypesParam 
SearchRequestBuilder searchRequestBuilder = this . client . prepareSearch ( 
indexParam ) 
. setSearchType ( SearchType . DFS_QUERY_THEN_FETCH ) 
. setQuery ( qbParam ) 
. setFrom ( 0 ) 
. setExplain ( false ) ; 
if ( withNoFieldsParam ) { 
searchRequestBuilder = searchRequestBuilder . storedFields ( NO_FIELDS_MAPPER ) ; 
if ( limitParam > 0 ) 
searchRequestBuilder = searchRequestBuilder . setSize ( limitParam ) ; 
if ( offsetParam > - 1 ) { 
searchRequestBuilder = searchRequestBuilder . setFrom ( offsetParam ) ; 
if ( formTypesParam == null ) 
formTypesParam = new Long [ ] { } ; 
if ( formTypesParam != null && formTypesParam . length > 0 ) 
String [ ] formTypesAsString = new String [ formTypesParam . length ] ; 
for ( int index = 0 ; index < formTypesParam . length ; index ++ ) 
Long formTypeId = formTypesParam [ index ] ; 
if ( formTypeId == null ) 
formTypesAsString [ index ] = formTypeId . toString ( ) ; 
searchRequestBuilder = searchRequestBuilder . setTypes ( formTypesAsString ) ; 
SearchResponse searchResponse = searchRequestBuilder . execute ( ) . actionGet ( ) ; 
if ( searchResponse == null ) { 
return searchResponse . getHits ( ) ; 
} public final boolean searchContainHits ( 
withNoFieldsParam , 
return ( searchHits != null && searchHits . getTotalHits ( ) > 0 ) ; 
} public final List < Form > getFormsByIds ( 
List < Long > formIdsParam , 
boolean includeFieldDataParam , 
int limitParam 
if ( formIdsParam == null || formIdsParam . isEmpty ( ) ) { 
if ( indexParam == null || indexParam . trim ( ) . isEmpty ( ) ) { 
StringBuffer byIdQuery = new StringBuffer ( ) ; 
for ( Long formId : formIdsParam ) { 
byIdQuery . append ( ABaseFluidJSONObject . JSONMapping . ID ) ; 
byIdQuery . append ( ":\"" ) ; 
byIdQuery . append ( formId ) ; 
String queryByIdsToString = byIdQuery . toString ( ) ; 
queryByIdsToString = queryByIdsToString . substring ( 0 , queryByIdsToString . length ( ) - 1 ) ; 
List < Form > returnVal = null ; 
if ( includeFieldDataParam ) { 
returnVal = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( queryByIdsToString ) , 
new Long [ ] { } ) ; 
returnVal = this . searchAndConvertHitsToFormWithNoFields ( 
if ( returnVal == null || returnVal . isEmpty ( ) ) { 
} public final List < Form > searchAndConvertHitsToFormWithAllFields ( 
( searchHits . getHits ( ) . length != limitParam ) ) { 
String source ; 
if ( ( source = searchHit . getSourceAsString ( ) ) == null ) { 
this . printInfoOnSourceFromES ( searchHit ) ; 
Form formFromSource = new Form ( ) ; 
JSONObject jsonObject = new JSONObject ( source ) ; 
List < Field > fieldsForForm = null ; 
if ( jsonObject . has ( Form . JSONMapping . FORM_TYPE_ID ) ) { 
if ( this . fieldUtil == null ) { 
fieldsForForm = formFromSource . convertTo ( 
this . fieldUtil . getFormFieldMappingForFormDefinition ( 
jsonObject . getLong ( Form . JSONMapping . FORM_TYPE_ID ) ) ) ; 
formFromSource . populateFromElasticSearchJson ( 
jsonObject , fieldsForForm ) ; 
returnVal . add ( formFromSource ) ; 
} public final List < Form > searchAndConvertHitsToFormWithNoFields ( 
new JSONObject ( source ) , 
} protected final List < Form > populateTableFields ( 
boolean addAllTableRecordsForReturnParam , 
List < Field > formFieldsParam ) { 
if ( formFieldsParam == null || formFieldsParam . isEmpty ( ) ) { 
List < Form > allTableRecordsFromAllFields = addAllTableRecordsForReturnParam ? 
new ArrayList ( ) : null ; 
for ( Field descendantField : formFieldsParam ) { 
if ( ! ( descendantField . getFieldValue ( ) instanceof TableField ) ) { 
TableField tableField = ( TableField ) descendantField . getFieldValue ( ) ; 
List < Form > tableRecordWithIdOnly = tableField . getTableRecords ( ) ; 
if ( tableRecordWithIdOnly == null || tableRecordWithIdOnly . isEmpty ( ) ) { 
List < Long > formIdsOnly = new ArrayList ( ) ; 
for ( Form tableRecord : tableRecordWithIdOnly ) { 
formIdsOnly . add ( tableRecord . getId ( ) ) ; 
List < Form > populatedTableRecords = this . getFormsByIds ( 
Index . TABLE_RECORD , 
formIdsOnly , 
includeFieldDataParam , 
DEFAULT_OFFSET , MAX_NUMBER_OF_TABLE_RECORDS ) ; 
if ( addAllTableRecordsForReturnParam && populatedTableRecords != null ) { 
allTableRecordsFromAllFields . addAll ( populatedTableRecords ) ; 
tableField . setTableRecords ( populatedTableRecords ) ; 
descendantField . setFieldValue ( tableField ) ; 
return allTableRecordsFromAllFields ; 
} public boolean doesIndexExist ( String indexToCheckParam ) { 
if ( indexToCheckParam == null || indexToCheckParam . trim ( ) . isEmpty ( ) ) { 
return this . client . admin ( ) . cluster ( ) 
. prepareState ( ) . execute ( ) 
. actionGet ( ) . getState ( ) 
. getMetaData ( ) . hasIndex ( indexToCheckParam ) ; 
public void closeConnection ( ) { 
CloseConnectionRunnable closeConnectionRunnable = 
new CloseConnectionRunnable ( this ) ; 
Thread closeConnThread = new Thread ( 
closeConnThread . start ( ) ; 
public boolean doesNameContain ( String containingTextParam ) { 
if ( this . getName ( ) == null || this . getName ( ) . trim ( ) . isEmpty ( ) ) { 
if ( containingTextParam == null || containingTextParam . trim ( ) . isEmpty ( ) ) { 
String paramLower = containingTextParam . toLowerCase ( ) ; 
String nameLower = this . getName ( ) . toLowerCase ( ) ; 
return nameLower . contains ( paramLower ) ; 
if ( this . getAttachmentDataBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . ATTACHMENT_DATA_BASE64 , 
this . getAttachmentDataBase64 ( ) ) ; 
if ( this . getContentType ( ) != null ) { 
returnVal . put ( JSONMapping . CONTENT_TYPE , this . getContentType ( ) ) ; 
if ( this . getFormId ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_ID , this . getFormId ( ) ) ; 
if ( this . getName ( ) != null ) { 
if ( this . getPath ( ) != null ) { 
returnVal . put ( JSONMapping . PATH , this . getPath ( ) ) ; 
if ( this . getVersion ( ) != null ) { 
returnVal . put ( JSONMapping . VERSION , this . getVersion ( ) ) ; 
if ( this . getDateCreated ( ) != null ) { 
this . getDateCreated ( ) . getTime ( ) ) ; 
if ( this . getDateLastUpdated ( ) != null ) { 
this . getDateLastUpdated ( ) . getTime ( ) ) ; 
} public List < Form > getTableForms ( 
Form formToGetTableFormsForParam , 
boolean includeFieldDataParam ) { 
if ( formToGetTableFormsForParam != null && this . serviceTicket != null ) { 
formToGetTableFormsForParam . setServiceTicket ( this . serviceTicket ) ; 
FormListing formListing = new FormListing ( 
this . postJson ( formToGetTableFormsForParam , 
WS . Path . SQLUtil . Version1 . getTableForms ( 
includeFieldDataParam ) ) ) ; 
return formListing . getListing ( ) ; 
catch ( JSONException e ) { 
throw new FluidClientException ( e . getMessage ( ) , e , 
} public List < Form > getDescendants ( 
Form formToGetDescendantsForParam , 
boolean includeTableFieldsParam , 
boolean inclTableFieldFormInfoParam ) { 
if ( formToGetDescendantsForParam != null && this . serviceTicket != null ) { 
formToGetDescendantsForParam . setServiceTicket ( this . serviceTicket ) ; 
this . postJson ( formToGetDescendantsForParam , 
WS . Path . SQLUtil . Version1 . getDescendants ( 
includeTableFieldsParam , 
inclTableFieldFormInfoParam ) ) ) ; 
} public Form getAncestor ( 
Form formToGetAncestorForParam , 
boolean includeTableFieldsParam ) { 
if ( formToGetAncestorForParam != null && this . serviceTicket != null ) { 
formToGetAncestorForParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( 
this . postJson ( formToGetAncestorForParam , 
WS . Path . SQLUtil . Version1 . getAncestor ( 
includeTableFieldsParam ) ) ) ; 
} public List < Field > getFormFields ( 
Form formToGetFieldsForParam , 
if ( formToGetFieldsForParam != null && this . serviceTicket != null ) { 
formToGetFieldsForParam . setServiceTicket ( this . serviceTicket ) ; 
FormFieldListing formFieldListing = new FormFieldListing ( 
this . postJson ( formToGetFieldsForParam , 
WS . Path . SQLUtil . Version1 . getFormFields ( 
return formFieldListing . getListing ( ) ; 
} public String toCamelUpperCase ( String inputParam ) { 
if ( inputParam == null ) 
if ( inputParam . isEmpty ( ) ) 
char [ ] original = inputParam . toCharArray ( ) ; 
StringBuilder titleCase = 
new StringBuilder ( Character . toString ( 
Character . toLowerCase ( original [ 0 ] ) ) ) ; 
boolean nextTitleCase = false ; 
for ( int index = 1 ; index < original . length ; index ++ ) 
char c = original [ index ] ; 
if ( Character . isSpaceChar ( c ) ) { 
nextTitleCase = true ; 
else if ( nextTitleCase ) { 
c = Character . toTitleCase ( c ) ; 
nextTitleCase = false ; 
titleCase . append ( c ) ; 
return titleCase . toString ( ) ; 
} public String getLatitudeFromFluidText ( String textToCheckParam ) { 
if ( textToCheckParam == null || textToCheckParam . isEmpty ( ) ) { 
String [ ] latitudeAndLongitude = textToCheckParam . split ( REG_EX_PIPE ) ; 
if ( latitudeAndLongitude == null || latitudeAndLongitude . length < 2 ) { 
latitudeAndLongitude = textToCheckParam . split ( REG_EX_COMMA ) ; 
if ( latitudeAndLongitude == null || latitudeAndLongitude . length == 0 ) { 
return ZERO ; 
if ( latitudeAndLongitude . length > 1 ) 
return toGoeSafe ( latitudeAndLongitude [ 0 ] ) ; 
} public double getLatitudeFromElasticSearchText ( String textToCheckParam ) 
String [ ] latitudeAndLongitude = textToCheckParam . split ( REG_EX_COMMA ) ; 
latitudeAndLongitude = textToCheckParam . split ( REG_EX_PIPE ) ; 
if ( latitudeAndLongitude . length > 1 ) { 
return toDoubleSafe ( latitudeAndLongitude [ 0 ] ) ; 
} public double getLongitudeFromElasticSearchText ( String textToCheckParam ) 
if ( textToCheckParam == null || textToCheckParam . trim ( ) . isEmpty ( ) ) { 
return this . toDoubleSafe ( latitudeAndLongitude [ 1 ] ) ; 
} public final double toDoubleSafe ( String toParseParam ) { 
if ( toParseParam == null || toParseParam . trim ( ) . isEmpty ( ) ) { 
return 0D ; 
return Double . parseDouble ( toParseParam ) ; 
} public final String toGoeSafe ( String toParseParam ) { 
for ( char charToCheck : toParseParam . toCharArray ( ) ) { 
if ( ! Character . isDigit ( charToCheck ) && '.' != charToCheck ) { 
if ( toParseParam . length ( ) > 12 ) { 
return toParseParam . substring ( 0 , 12 ) ; 
return toParseParam ; 
} public static byte [ ] decodeBase64 ( String base64StringParam ) 
if ( base64StringParam == null ) 
if ( base64StringParam . isEmpty ( ) ) 
return new byte [ ] { } ; 
return Base64 . getDecoder ( ) . decode ( base64StringParam ) ; 
} public static String encodeBase16 ( byte [ ] bytesParam ) 
if ( bytesParam == null ) 
if ( bytesParam . length == 0 ) 
return UtilGlobal . EMPTY ; 
return DatatypeConverter . printHexBinary ( bytesParam ) . toUpperCase ( ) ; 
} public static byte [ ] decodeBase16 ( String stringParam ) { 
if ( stringParam == null ) 
if ( stringParam . trim ( ) . isEmpty ( ) ) 
int len = stringParam . length ( ) ; 
byte [ ] data = new byte [ len / 2 ] ; 
for ( int i = 0 ; i < len ; i += 2 ) { 
data [ i / 2 ] = ( byte ) ( ( Character . digit ( stringParam . charAt ( i ) , 16 ) << 4 ) 
+ Character . digit ( stringParam . charAt ( i + 1 ) , 16 ) ) ; 
} public static String encodeBase64 ( byte [ ] bytesParam ) 
return Base64 . getEncoder ( ) . encodeToString ( bytesParam ) ; 
} public void setFlatFieldOnJSONObj ( 
String fieldNamePrefixParam , 
String fieldNameIdPrefixParam , 
Field fieldToExtractFromParam , 
JSONObject objectToSetFieldOnParam ) 
if ( fieldToExtractFromParam == null ) 
String fieldName = fieldToExtractFromParam . getFieldNameAsUpperCamel ( ) ; 
if ( fieldName == null || fieldName . trim ( ) . isEmpty ( ) ) 
String completeFieldName = fieldNamePrefixParam . concat ( fieldName ) ; 
String completeFieldNameId = fieldNameIdPrefixParam . concat ( fieldName ) ; 
objectToSetFieldOnParam . put ( completeFieldNameId , 
fieldToExtractFromParam . getId ( ) ) ; 
Object fieldValue = fieldToExtractFromParam . getFieldValue ( ) ; 
objectToSetFieldOnParam . put ( 
completeFieldName , 
JSONObject . NULL ) ; 
else if ( fieldValue instanceof TableField ) 
else if ( fieldValue instanceof MultiChoice ) { 
MultiChoice multiChoice = ( MultiChoice ) fieldValue ; 
if ( multiChoice . getSelectedMultiChoices ( ) == null || 
multiChoice . getSelectedMultiChoices ( ) . isEmpty ( ) ) 
multiChoice . getSelectedMultiChoices ( ) . forEach ( selectedChoice -> 
builder . append ( selectedChoice ) ; 
String selectVal = builder . toString ( ) ; 
if ( selectVal != null && ! selectVal . trim ( ) . isEmpty ( ) ) 
selectVal = selectVal . substring ( 0 , selectVal . length ( ) - 2 ) ; 
objectToSetFieldOnParam . put ( completeFieldName , selectVal ) ; 
if ( ( fieldValue instanceof String ) && 
Field . LATITUDE_AND_LONGITUDE . equals ( 
fieldToExtractFromParam . getTypeMetaData ( ) ) ) 
String latitudeTxt = this . getLatitudeFromFluidText ( formFieldValueStr ) ; 
String longitudeTxt = this . getLongitudeFromFluidText ( formFieldValueStr ) ; 
fieldValue = ( latitudeTxt . concat ( UtilGlobal . COMMA ) . concat ( longitudeTxt ) ) ; 
objectToSetFieldOnParam . put ( completeFieldName , fieldValue ) ; 
objectToSetFieldOnParam . put ( completeFieldName , ( ( Date ) fieldValue ) . getTime ( ) ) ; 
} public Object doesHandlerQualifyForProcessing ( String messageParam ) { 
JSONObject jsonObject = null ; 
jsonObject = new JSONObject ( messageParam ) ; 
jsonExcept . getMessage ( ) , 
Error fluidError = new Error ( jsonObject ) ; 
if ( fluidError . getErrorCode ( ) > 0 ) { 
return fluidError ; 
String echo = fluidError . getEcho ( ) ; 
if ( this . expectedEchoMessagesBeforeComplete . contains ( echo ) ) { 
public void handleMessage ( Object objectToProcess ) { 
if ( objectToProcess instanceof Error ) { 
Error fluidError = ( ( Error ) objectToProcess ) ; 
this . errors . add ( fluidError ) ; 
if ( this . messageReceivedCallback != null ) 
this . messageReceivedCallback . errorMessageReceived ( fluidError ) ; 
if ( this . completableFuture != null ) 
this . completableFuture . completeExceptionally ( 
new FluidClientException ( 
fluidError . getErrorMessage ( ) , 
fluidError . getErrorCode ( ) ) ) ; 
JSONObject jsonObject = ( JSONObject ) objectToProcess ; 
if ( this . compressedResponse ) { 
CompressedResponse compressedResponse = new CompressedResponse ( jsonObject ) ; 
byte [ ] compressedJsonList = 
UtilGlobal . decodeBase64 ( compressedResponse . getDataBase64 ( ) ) ; 
byte [ ] uncompressedJson = null ; 
uncompressedJson = this . uncompress ( compressedJsonList ) ; 
} catch ( IOException eParam ) { 
eParam , 
FluidClientException . ErrorCode . IO_ERROR ) ; 
jsonObject = new JSONObject ( new String ( uncompressedJson ) ) ; 
T messageForm = this . getNewInstanceBy ( jsonObject ) ; 
this . returnValue . add ( messageForm ) ; 
String echo = messageForm . getEcho ( ) ; 
if ( echo != null && ! echo . trim ( ) . isEmpty ( ) ) 
this . expectedEchoMessagesBeforeComplete . remove ( echo ) ; 
if ( this . expectedEchoMessagesBeforeComplete . isEmpty ( ) ) 
this . completableFuture . complete ( this . returnValue ) ; 
this . messageReceivedCallback . messageReceived ( messageForm ) ; 
public void connectionClosed ( ) { 
this . isConnectionClosed = true ; 
if ( this . getErrors ( ) . isEmpty ( ) ) 
Error firstFluidError = this . getErrors ( ) . get ( 0 ) ; 
this . completableFuture . completeExceptionally ( new FluidClientException ( 
firstFluidError . getErrorMessage ( ) , 
firstFluidError . getErrorCode ( ) ) ) ; 
} public void addExpectedMessage ( String expectedMessageEchoParam ) 
if ( expectedMessageEchoParam == null || 
expectedMessageEchoParam . trim ( ) . isEmpty ( ) ) { 
this . expectedEchoMessagesBeforeComplete . add ( expectedMessageEchoParam ) ; 
} private List < String > getEchoMessagesFromReturnValue ( ) 
List < String > returnListing = new ArrayList ( ) ; 
if ( this . returnValue == null ) 
return returnListing ; 
Iterator < T > iterForReturnVal = 
this . returnValue . iterator ( ) ; 
while ( iterForReturnVal . hasNext ( ) ) 
T returnVal = iterForReturnVal . next ( ) ; 
if ( returnVal . getEcho ( ) == null ) 
returnListing . add ( returnVal . getEcho ( ) ) ; 
} public boolean doReturnValueEchoMessageContainAll ( 
List < String > echoMessageParam ) 
if ( echoMessageParam == null || echoMessageParam . isEmpty ( ) ) 
List < String > allReturnValueEchoMessages = 
this . getEchoMessagesFromReturnValue ( ) ; 
for ( String toCheckFor : echoMessageParam ) 
if ( ! allReturnValueEchoMessages . contains ( toCheckFor ) ) 
} protected byte [ ] uncompress ( 
byte [ ] compressedBytesParam 
) throws IOException { 
byte [ ] returnVal = null ; 
ZipInputStream zis = null ; 
if ( CHARSET == null ) { 
zis = new ZipInputStream ( 
new ByteArrayInputStream ( compressedBytesParam ) ) ; 
new ByteArrayInputStream ( compressedBytesParam ) , 
CHARSET ) ; 
ZipEntry ze = zis . getNextEntry ( ) ; 
if ( ze == null ) { 
while ( ( len = zis . read ( buffer ) ) > 0 ) { 
bos . write ( buffer , 0 , len ) ; 
zis . closeEntry ( ) ; 
zis . close ( ) ; 
bos . flush ( ) ; 
bos . close ( ) ; 
returnVal = bos . toByteArray ( ) ; 
} public List < FluidItem > getPersonalInventoryItems ( ) 
User loggedInUser = new User ( ) ; 
loggedInUser . setServiceTicket ( this . serviceTicket ) ; 
return new FluidItemListing ( this . postJson ( 
loggedInUser , 
WS . Path . PersonalInventory . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; 
} public Form removeFromPersonalInventory ( Form formToRemoveParam ) 
if ( formToRemoveParam != null && 
this . serviceTicket != null ) 
formToRemoveParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( 
formToRemoveParam , 
WS . Path . PersonalInventory . Version1 . removeFromPersonalInventory ( ) ) ) ; 
if ( this . getEncryptedDataBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . ENCRYPTED_DATA_BASE_64 , this . getEncryptedDataBase64 ( ) ) ; 
if ( this . getEncryptedDataHmacBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . ENCRYPTED_DATA_HMAC_BASE_64 , this . getEncryptedDataHmacBase64 ( ) ) ; 
if ( this . getIvBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . IV_BASE_64 , this . getIvBase64 ( ) ) ; 
if ( this . getSeedBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . SEED_BASE_64 , this . getSeedBase64 ( ) ) ; 
if ( this . getServiceTicket ( ) != null ) { 
returnVal . put ( ABaseFluidJSONObject . JSONMapping . SERVICE_TICKET , this . getServiceTicket ( ) ) ; 
if ( this . getSalt ( ) != null ) { 
if ( this . getPrincipalClient ( ) != null ) { 
returnVal . put ( JSONMapping . PRINCIPAL_CLIENT , this . getPrincipalClient ( ) ) ; 
if ( this . getRoleString ( ) != null ) { 
returnVal . put ( JSONMapping . ROLE_STRING , this . getRoleString ( ) ) ; 
if ( this . getTimestamp ( ) != null ) { 
returnVal . put ( JSONMapping . TIMESTAMP , this . getTimestamp ( ) ) ; 
} public Form createFormContainer ( Form formParam ) { 
return new Form ( this . putJson ( 
formParam , WS . Path . FormContainer . Version1 . formContainerCreate ( ) ) ) ; 
} public TableRecord createTableRecord ( TableRecord tableRecordParam ) { 
if ( tableRecordParam != null && this . serviceTicket != null ) { 
tableRecordParam . setServiceTicket ( this . serviceTicket ) ; 
return new TableRecord ( this . putJson ( 
tableRecordParam , 
WS . Path . FormContainerTableRecord . Version1 . formContainerTableRecordCreate ( ) ) ) ; 
} public Form updateFormContainer ( Form formParam ) { 
formParam , WS . Path . FormContainer . Version1 . formContainerUpdate ( ) ) ) ; 
} public Form executeCustomWebAction ( 
String customWebActionParam , 
Form formParam ) { 
return this . executeCustomWebAction ( 
customWebActionParam , 
formParam ) ; 
boolean isTableRecordParam , 
Long formContainerTableRecordBelowsToParam , 
if ( customWebActionParam == null || customWebActionParam . trim ( ) . isEmpty ( ) ) { 
formParam , WS . Path . FormContainer . Version1 . executeCustomWebAction ( 
isTableRecordParam , 
formContainerTableRecordBelowsToParam ) ) ) ; 
} catch ( UnsupportedEncodingException unsEncExcept ) { 
} public Form deleteFormContainer ( Form formContainerParam ) { 
if ( formContainerParam != null && this . serviceTicket != null ) { 
formContainerParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( formContainerParam , 
WS . Path . FormContainer . Version1 . formContainerDelete ( ) ) ) ; 
} public List < FormFlowHistoricData > getFormFlowHistoricData ( Form formParam ) { 
return new FormFlowHistoricDataListing ( this . postJson ( 
formParam , WS . Path . FlowItemHistory . Version1 . getByFormContainer ( ) ) ) . getListing ( ) ; 
} public List < FormHistoricData > getFormAndFieldHistoricData ( 
Form formParam , 
boolean includeCurrentParam 
if ( formParam != null && this . serviceTicket != null ) 
return new FormHistoricDataListing ( this . postJson ( 
formParam , WS . Path . FormHistory . Version1 . getByFormContainer ( 
includeCurrentParam ) ) ) . getListing ( ) ; 
} public FormHistoricData getMostRecentFormAndFieldHistoricData ( Form formParam ) { 
return new FormHistoricData ( this . postJson ( 
formParam , WS . Path . FormHistory . Version1 . getByMostRecentByFormContainer ( ) ) ) ; 
} public Form getFormContainerById ( Long formContainerIdParam ) { 
Form form = new Form ( formContainerIdParam ) ; 
form . setServiceTicket ( this . serviceTicket ) ; 
form , WS . Path . FormContainer . Version1 . getById ( ) ) ) ; 
} public Form lockFormContainer ( 
JobView jobViewParam 
return this . lockFormContainer ( 
formParam , jobViewParam , null ) ; 
JobView jobViewParam , 
User userToLockAsParam 
if ( this . serviceTicket != null && formParam != null ) { 
Long jobViewId = ( jobViewParam == null ) ? 
null : jobViewParam . getId ( ) ; 
Long lockAsUserId = ( userToLockAsParam == null ) ? 
null : userToLockAsParam . getId ( ) ; 
formParam , 
WS . Path . FormContainer . Version1 . lockFormContainer ( 
jobViewId , lockAsUserId ) ) ) ; 
} public Form unLockFormContainer ( 
boolean unlockAsyncParam ) { 
return this . unLockFormContainer ( 
formParam , null , unlockAsyncParam , false ) ; 
User userToUnLockAsParam ) { 
formParam , userToUnLockAsParam , true , false ) ; 
User userToUnLockAsParam , 
userToUnLockAsParam , 
unlockAsyncParam , 
boolean unlockAsyncParam , 
boolean removeFromPersonalInventoryParam ) { 
Long unLockAsUserId = ( userToUnLockAsParam == null ) ? 
null : userToUnLockAsParam . getId ( ) ; 
WS . Path . FormContainer . Version1 . unLockFormContainer ( 
unLockAsUserId , 
removeFromPersonalInventoryParam ) ) ) ; 
} public List < Form > getFormTableForms ( 
Long electronicFormIdParam , 
boolean includeFieldDataParam 
List < Form > returnVal = new ArrayList ( ) ; 
if ( electronicFormIdParam == null ) { 
Map < Long , String > definitionAndTitle = 
this . formDefUtil . getFormDefinitionIdAndTitle ( ) ; 
PreparedStatement preparedStatement = null ; 
ResultSet resultSet = null ; 
ISyntax syntax = SyntaxFactory . getInstance ( ) . getSyntaxFor ( 
this . getSQLTypeFromConnection ( ) , 
ISyntax . ProcedureMapping . Form . GetFormContainersTableFieldFormContainers ) ; 
preparedStatement = this . getConnection ( ) . prepareStatement ( 
syntax . getPreparedStatement ( ) ) ; 
preparedStatement . setLong ( 1 , electronicFormIdParam ) ; 
resultSet = preparedStatement . executeQuery ( ) ; 
while ( resultSet . next ( ) ) 
returnVal . add ( this . mapFormContainerTo ( 
definitionAndTitle , 
resultSet ) ) ; 
if ( includeFieldDataParam ) 
for ( Form form : returnVal ) 
List < Field > formFields = this . fieldUtil . getFormFields ( 
form . getId ( ) , 
form . setFormFields ( formFields ) ; 
} catch ( SQLException sqlError ) { 
throw new FluidSQLException ( sqlError ) ; 
this . closeStatement ( preparedStatement , resultSet ) ; 
public List < Form > getFormDescendants ( 
List < Long > electronicFormIdsParam , 
boolean includeTableFieldFormRecordInfoParam ) { 
if ( electronicFormIdsParam == null || electronicFormIdsParam . isEmpty ( ) ) { 
for ( Long electronicFormId : electronicFormIdsParam ) { 
List < Form > forTheCycle = this . getFormDescendants ( 
electronicFormId , 
includeTableFieldFormRecordInfoParam ) ; 
if ( forTheCycle == null ) { 
returnVal . addAll ( forTheCycle ) ; 
} public Form getFormAncestor ( 
boolean includeTableFieldsParam 
Form returnVal = null ; 
ISyntax . ProcedureMapping . Form . GetFormContainersParentFormContainer ) ; 
if ( resultSet . next ( ) ) { 
returnVal = this . mapFormContainerTo ( 
resultSet ) ; 
if ( includeFieldDataParam && returnVal != null ) { 
returnVal . setFormFields ( 
this . fieldUtil . getFormFields ( 
returnVal . getId ( ) , 
false ) ) ; 
} private Form mapFormContainerTo ( 
Map < Long , String > definitionAndTitleParam , 
ResultSet resultSetParam 
) throws SQLException { 
Long formId = resultSetParam . getLong ( SQLColumnIndex . _01_FORM_ID ) ; 
String formType = definitionAndTitleParam . get ( 
resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) ) ; 
String title = resultSetParam . getString ( SQLColumnIndex . _03_TITLE ) ; 
Date created = resultSetParam . getDate ( SQLColumnIndex . _04_CREATED ) ; 
Date lastUpdated = resultSetParam . getDate ( SQLColumnIndex . _05_LAST_UPDATED ) ; 
Long currentUserId = resultSetParam . getLong ( SQLColumnIndex . _06_CURRENT_USER_ID ) ; 
if ( formType == null ) { 
resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) + "'." ) ; 
Form toAdd = new Form ( formType ) ; 
toAdd . setId ( formId ) ; 
toAdd . setTitle ( title ) ; 
if ( created != null ) { 
toAdd . setDateCreated ( new Date ( created . getTime ( ) ) ) ; 
if ( lastUpdated != null ) { 
toAdd . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; 
if ( currentUserId != null && 
currentUserId . longValue ( ) > 0 ) { 
User currentUser = new User ( ) ; 
currentUser . setId ( currentUserId ) ; 
toAdd . setCurrentUser ( currentUser ) ; 
} private void mapFormContainerStatesTo ( 
Form previousMappedForm , 
if ( previousMappedForm == null ) { 
Long formContainerState = resultSetParam . getLong ( 
SQLColumnIndex . _07_FORM_CONTAINER_STATE ) ; 
long formContStateId = ( formContainerState == null ) ? 
0 : formContainerState . longValue ( ) ; 
if ( formContStateId > 0 ) { 
if ( formContStateId == 1 ) 
previousMappedForm . setState ( Form . State . OPEN ) ; 
else if ( formContStateId == 2 ) 
previousMappedForm . setState ( Form . State . LOCKED ) ; 
Long formContainerFlowState = resultSetParam . getLong ( 
SQLColumnIndex . _08_FORM_CONTAINER_FLOW_STATE ) ; 
long formContFlowStateId = ( formContainerFlowState == null ) ? 
0 : formContainerFlowState . longValue ( ) ; 
if ( formContFlowStateId > 0 ) { 
if ( formContFlowStateId == 1 ) { 
previousMappedForm . setFlowState ( 
FluidItem . FlowState . NotInFlow . name ( ) ) ; 
else if ( formContFlowStateId == 2 ) { 
FluidItem . FlowState . WorkInProgress . name ( ) ) ; 
else if ( formContFlowStateId == 3 ) { 
FluidItem . FlowState . UserSend . name ( ) ) ; 
else if ( formContFlowStateId == 4 ) { 
FluidItem . FlowState . UserSendWorkInProgress . name ( ) ) ; 
else if ( formContFlowStateId == 5 ) { 
previousMappedForm . setFlowState ( FluidItem . FlowState . Archive . name ( ) ) ; 
public static List < Role > convertToObjects ( String roleListingParam ) 
if ( roleListingParam == null || roleListingParam . trim ( ) . isEmpty ( ) ) 
String [ ] listOfRoles = roleListingParam . split ( UtilGlobal . REG_EX_COMMA ) ; 
List < Role > returnVal = new ArrayList < > ( ) ; 
for ( String roleName : listOfRoles ) 
Role roleToAdd = new Role ( ) ; 
roleToAdd . setName ( roleName . trim ( ) ) ; 
returnVal . add ( roleToAdd ) ; 
if ( this . getAdminPermissions ( ) != null && 
! this . getAdminPermissions ( ) . isEmpty ( ) ) 
JSONArray adminPerArr = new JSONArray ( ) ; 
for ( String toAdd : this . getAdminPermissions ( ) ) 
adminPerArr . put ( toAdd ) ; 
returnVal . put ( JSONMapping . ADMIN_PERMISSIONS , adminPerArr ) ; 
if ( this . getRoleToFormDefinitions ( ) != null && 
! this . getRoleToFormDefinitions ( ) . isEmpty ( ) ) 
JSONArray roleToFormDefArr = new JSONArray ( ) ; 
for ( RoleToFormDefinition toAdd : this . getRoleToFormDefinitions ( ) ) 
roleToFormDefArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLE_TO_FORM_DEFINITIONS , roleToFormDefArr ) ; 
if ( this . getRoleToFormFieldToFormDefinitions ( ) != null && 
! this . getRoleToFormFieldToFormDefinitions ( ) . isEmpty ( ) ) 
JSONArray roleToJobViewArr = new JSONArray ( ) ; 
for ( RoleToFormFieldToFormDefinition toAdd : this . getRoleToFormFieldToFormDefinitions ( ) ) 
roleToJobViewArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLE_TO_FORM_FIELD_TO_FORM_DEFINITIONS , roleToJobViewArr ) ; 
if ( this . getRoleToJobViews ( ) != null && 
! this . getRoleToJobViews ( ) . isEmpty ( ) ) 
for ( RoleToJobView toAdd : this . getRoleToJobViews ( ) ) 
returnVal . put ( JSONMapping . ROLE_TO_JOB_VIEWS , roleToJobViewArr ) ; 
if ( this . getRoleToUserQueries ( ) != null && 
! this . getRoleToUserQueries ( ) . isEmpty ( ) ) 
JSONArray userQueriesArr = new JSONArray ( ) ; 
for ( RoleToUserQuery toAdd : this . getRoleToUserQueries ( ) ) 
userQueriesArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLE_TO_USER_QUERIES , userQueriesArr ) ; 
} public Form createFormDefinition ( Form formDefinitionParam ) 
if ( formDefinitionParam != null && this . serviceTicket != null ) 
formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; 
formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionCreate ( ) ) ) ; 
} public Form updateFormDefinition ( Form formDefinitionParam ) 
formDefinitionParam , 
WS . Path . FormDefinition . Version1 . formDefinitionUpdate ( ) ) ) ; 
} public Form getFormDefinitionById ( Long formDefinitionIdParam ) 
Form form = new Form ( formDefinitionIdParam ) ; 
form , WS . Path . FormDefinition . Version1 . getById ( ) ) ) ; 
} public Form getFormDefinitionByName ( String formDefinitionNameParam ) 
Form form = new Form ( formDefinitionNameParam ) ; 
form , WS . Path . FormDefinition . Version1 . getByName ( ) ) ) ; 
} public List < Form > getAllByLoggedInUser ( boolean includeTableRecordTypesParam ) 
Form form = new Form ( ) ; 
if ( includeTableRecordTypesParam ) 
return new FormListing ( this . postJson ( 
form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUserIncludeTableTypes ( ) ) ) . getListing ( ) ; 
form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; 
} public List < Form > getAllByLoggedInUserWhereCanCreateInstanceOf ( ) 
form , WS . Path . FormDefinition . Version1 . getAllByLoggedInAndCanCreateInstanceOf ( ) ) ) . 
getListing ( ) ; 
} public Form deleteFormDefinition ( Form formDefinitionParam ) 
return new Form ( this . postJson ( formDefinitionParam , 
WS . Path . FormDefinition . Version1 . formDefinitionDelete ( ) ) ) ; 
} public CachedFieldValue getCachedFieldValueFrom ( 
Long formDefIdParam , 
Long formContIdParam , 
Long formFieldIdParam ) 
if ( ( formDefIdParam == null || formContIdParam == null ) || 
formFieldIdParam == null ) 
String storageKey = this . getStorageKeyFrom ( 
formDefIdParam , 
formContIdParam , 
formFieldIdParam ) ; 
Object objWithKey ; 
objWithKey = this . memcachedClient . get ( storageKey ) ; 
catch ( MemcachedException e ) { 
} catch ( TimeoutException e ) { 
return this . getCacheFieldValueFromObject ( objWithKey ) ; 
private CachedFieldValue getCacheFieldValueFromObject ( Object objWithKeyParam ) 
if ( objWithKeyParam == null ) 
Method methodGetWord = CacheUtil . getMethod ( 
objWithKeyParam . getClass ( ) , 
CustomCode . IWord . METHOD_getWord ) ; 
Method methodGetValue = CacheUtil . getMethod ( 
CustomCode . ADataType . METHOD_getValue ) ; 
Object getWordObj = CacheUtil . invoke ( methodGetWord , objWithKeyParam ) ; 
String getWordVal = null ; 
if ( getWordObj instanceof String ) 
getWordVal = ( String ) getWordObj ; 
Object getValueObj ; 
if ( FlowJobType . MULTIPLE_CHOICE . equals ( getWordVal ) ) 
MultiChoice multiChoice = new MultiChoice ( ) ; 
Method methodAvailableChoices = getMethod ( 
CustomCode . MultipleChoice . METHOD_getAvailableChoices ) ; 
Object availChoicesObj = 
CacheUtil . invoke ( methodAvailableChoices , objWithKeyParam ) ; 
if ( availChoicesObj instanceof List ) 
multiChoice . setAvailableMultiChoices ( ( List ) availChoicesObj ) ; 
Method methodSelectedChoices = getMethod ( 
CustomCode . MultipleChoice . METHOD_getSelectedChoices ) ; 
Object selectedChoicesObj = 
invoke ( methodSelectedChoices , objWithKeyParam ) ; 
if ( selectedChoicesObj instanceof List ) 
multiChoice . setSelectedMultiChoices ( ( List ) selectedChoicesObj ) ; 
getValueObj = multiChoice ; 
getValueObj = CacheUtil . invoke ( methodGetValue , objWithKeyParam ) ; 
if ( getValueObj == null ) 
if ( getWordVal == null ) 
throw new FluidCacheException ( 
CachedFieldValue returnVal = new CachedFieldValue ( ) ; 
returnVal . dataType = getWordVal ; 
returnVal . cachedFieldValue = getValueObj ; 
private static Method getMethod ( Class clazzParam , String nameParam ) 
if ( clazzParam == null || nameParam == null ) 
Method returnVal = clazzParam . getDeclaredMethod ( nameParam ) ; 
returnVal . setAccessible ( true ) ; 
catch ( NoSuchMethodException e ) { 
} private static Object invoke ( Method methodParam , Object objParam ) 
return methodParam . invoke ( objParam ) ; 
} private String getStorageKeyFrom ( 
StringBuilder stringBuff = new StringBuilder ( ) ; 
if ( formDefIdParam == null ) 
stringBuff . append ( NULL ) ; 
stringBuff . append ( formDefIdParam . toString ( ) ) ; 
stringBuff . append ( DASH ) ; 
if ( formContIdParam == null ) 
stringBuff . append ( formContIdParam . toString ( ) ) ; 
if ( formFieldIdParam == null ) 
stringBuff . append ( formFieldIdParam . toString ( ) ) ; 
return stringBuff . toString ( ) ; 
} private MemcachedClient initXMemcachedClient ( ) 
if ( this . memcachedClient != null && ! this . memcachedClient . isShutdown ( ) ) 
return this . memcachedClient ; 
this . memcachedClient = new XMemcachedClient ( 
this . cacheHost , this . cachePort ) ; 
if ( this . memcachedClient != null && 
! this . memcachedClient . isShutdown ( ) ) 
this . memcachedClient . shutdown ( ) ; 
catch ( IOException eParam ) { 
if ( this . getOrder ( ) != null ) 
returnVal . put ( JSONMapping . ORDER , this . getOrder ( ) ) ; 
if ( this . getRule ( ) != null ) 
returnVal . put ( JSONMapping . RULE , this . getRule ( ) ) ; 
if ( this . getCurrentTypedSyntax ( ) != null ) 
returnVal . put ( JSONMapping . CURRENT_TYPED_SYNTAX , 
this . getCurrentTypedSyntax ( ) ) ; 
returnVal . put ( JSONMapping . FLOW , this . getFlow ( ) . toJsonObject ( ) ) ; 
if ( this . getFlowStep ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STEP , this . getFlowStep ( ) . toJsonObject ( ) ) ; 
if ( this . getNextValidSyntaxWords ( ) != null && ! this . getNextValidSyntaxWords ( ) . isEmpty ( ) ) 
JSONArray jsonArrayOfValidWords = new JSONArray ( ) ; 
for ( String validWord : this . getNextValidSyntaxWords ( ) ) 
jsonArrayOfValidWords . put ( validWord ) ; 
returnVal . put ( JSONMapping . NEXT_VALID_SYNTAX_WORDS , jsonArrayOfValidWords ) ; 
} public List < FormListing > getDescendantsSynchronized ( 
Form ... formToGetDescendantsForParam ) { 
if ( formToGetDescendantsForParam == null || 
formToGetDescendantsForParam . length == 0 ) { 
String uniqueReqId = this . initNewRequest ( ) ; 
int numberOfSentForms = 0 ; 
if ( this . massFetch ) { 
FormListing listingToSend = new FormListing ( ) ; 
List < Form > listOfValidForms = new ArrayList ( ) ; 
for ( Form formToSend : formToGetDescendantsForParam ) { 
if ( formToSend == null ) { 
FluidClientException . ErrorCode . ILLEGAL_STATE_ERROR ) ; 
listOfValidForms . add ( new Form ( formToSend . getId ( ) ) ) ; 
listingToSend . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
listingToSend . setListing ( listOfValidForms ) ; 
this . sendMessage ( listingToSend , uniqueReqId ) ; 
numberOfSentForms ++ ; 
this . setEchoIfNotSet ( formToSend ) ; 
this . sendMessage ( formToSend , uniqueReqId ) ; 
List < FormListing > returnValue = 
this . getHandler ( uniqueReqId ) . getCF ( ) . get ( 
this . getTimeoutInMillis ( ) , TimeUnit . MILLISECONDS ) ; 
if ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) { 
} catch ( InterruptedException exceptParam ) { 
exceptParam . getMessage ( ) , 
exceptParam , 
FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; 
} catch ( ExecutionException executeProblem ) { 
Throwable cause = executeProblem . getCause ( ) ; 
if ( cause instanceof FluidClientException ) { 
throw ( FluidClientException ) cause ; 
cause . getMessage ( ) , cause , 
} catch ( TimeoutException eParam ) { 
String errMessage = this . getExceptionMessageVerbose ( 
"SQLUtil-WebSocket-GetDescendants" , 
uniqueReqId , 
numberOfSentForms ) ; 
errMessage , FluidClientException . ErrorCode . IO_ERROR ) ; 
this . removeHandler ( uniqueReqId ) ; 
} protected static String getStringPropertyFromProperties ( 
Properties propertiesParam , 
String propertyKeyParam 
if ( propertiesParam == null || propertiesParam . isEmpty ( ) ) { 
return propertiesParam . getProperty ( propertyKeyParam ) ; 
} protected static int getIntPropertyFromProperties ( 
String strProp = getStringPropertyFromProperties ( 
propertiesParam , propertyKeyParam ) ; 
if ( strProp == null || strProp . trim ( ) . isEmpty ( ) ) { 
return Integer . parseInt ( strProp ) ; 
} protected long toLongSafe ( String toParseParam ) { 
return Long . parseLong ( toParseParam . trim ( ) ) ; 
returnVal . put ( JSONMapping . FLOW , this . getFlow ( ) ) ; 
if ( this . getForm ( ) != null ) 
returnVal . put ( JSONMapping . FORM , this . getForm ( ) . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . USER_FIELDS , fieldsArr ) ; 
if ( this . getAttachments ( ) != null ) 
for ( Attachment toAdd : this . getAttachments ( ) ) 
jsonArray . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ATTACHMENTS , jsonArray ) ; 
if ( this . getFlowState ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STATE , this . getFlowState ( ) . toString ( ) ) ; 
public JSONObject convertToFlatJSONObject ( ) 
FlatFormJSONMapping . FLUID_ITEM_ID , 
this . getId ( ) == null ? 
JSONObject . NULL : this . getId ( ) ) ; 
FlatFormJSONMapping . FLOW_STATE , 
( this . getFlowState ( ) == null ) ? 
JSONObject . NULL : this . getFlowState ( ) . name ( ) ) ; 
JSONObject formJSONObjFlat = 
( this . getForm ( ) == null ) ? null : 
this . getForm ( ) . convertToFlatJSONObject ( ) ; 
if ( formJSONObjFlat != null ) 
formJSONObjFlat . keySet ( ) . forEach ( 
( toAdd ) -> 
returnVal . put ( toAdd , formJSONObjFlat . get ( toAdd ) ) ; 
if ( this . isCanCreate ( ) != null ) 
returnVal . put ( JSONMapping . CAN_CREATE , 
this . isCanCreate ( ) . booleanValue ( ) ) ; 
if ( this . getFormDefinition ( ) != null ) 
returnVal . put ( JSONMapping . FORM_DEFINITION , 
this . getFormDefinition ( ) . toJsonObject ( ) ) ; 
} public String getListOfProvidersFromIdentities ( ) 
if ( this . getIdentities ( ) == null || this . getIdentities ( ) . isEmpty ( ) ) 
StringBuilder returnVal = new StringBuilder ( ) ; 
for ( Identity identity : this . getIdentities ( ) ) 
returnVal . append ( identity . getProvider ( ) ) ; 
returnVal . append ( "," ) ; 
String toString = returnVal . toString ( ) ; 
return toString . substring ( 0 , toString . length ( ) - 1 ) ; 
if ( this . getUserId ( ) != null ) 
returnVal . put ( JSONMapping . USER_ID , this . getUserId ( ) ) ; 
if ( this . getEmail ( ) != null ) 
returnVal . put ( JSONMapping . EMAIL , this . getEmail ( ) ) ; 
returnVal . put ( JSONMapping . EMAIL_VERIFIED , this . isEmailVerified ( ) ) ; 
if ( this . getNickname ( ) != null ) 
returnVal . put ( JSONMapping . NICKNAME , this . getNickname ( ) ) ; 
if ( this . getPicture ( ) != null ) 
returnVal . put ( JSONMapping . PICTURE , this . getPicture ( ) ) ; 
if ( this . getGivenName ( ) != null ) 
returnVal . put ( JSONMapping . GIVEN_NAME , this . getGivenName ( ) ) ; 
if ( this . getFamilyName ( ) != null ) 
returnVal . put ( JSONMapping . FAMILY_NAME , this . getFamilyName ( ) ) ; 
if ( this . getLocale ( ) != null ) 
if ( this . getIdentities ( ) != null && ! this . getIdentities ( ) . isEmpty ( ) ) 
JSONArray identitiesArr = new JSONArray ( ) ; 
for ( Identity toAdd : this . getIdentities ( ) ) 
identitiesArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . IDENTITIES , identitiesArr ) ; 
} public File convertDocumentToPDF ( File inputDocumentParam ) { 
if ( inputDocumentParam == null || 
! inputDocumentParam . exists ( ) ) 
throw new UtilException ( 
UtilException . ErrorCode . COMMAND ) ; 
if ( ! inputDocumentParam . isFile ( ) ) 
File parentFolder = inputDocumentParam . getParentFile ( ) ; 
String inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; 
int indexOfDot = - 1 ; 
if ( ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) > - 1 ) 
inputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; 
File generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( 
File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( ".pdf" ) ) ; 
String completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; 
CommandUtil . CommandResult commandResult = 
this . commandUtil . executeCommand ( 
CommandUtil . FLUID_CLI , 
COMMAND_CONVERT_DOC_TO_PDF , 
"-i" , 
inputDocumentParam . getAbsolutePath ( ) , 
"-o" , 
completeOutputPath ) ; 
if ( commandResult . getExitCode ( ) != 0 ) 
inputDocumentParam . getName ( ) + 
File returnVal = new File ( completeOutputPath ) ; 
if ( ! returnVal . exists ( ) ) 
completeOutputPath + "'." , 
UtilException . ErrorCode . GENERAL ) ; 
eParam , UtilException . ErrorCode . GENERAL ) ; 
if ( DISABLE_WS ) { 
this . mode = Mode . RESTfulActive ; 
if ( this . getAncestorClient == null && 
Mode . RESTfulActive != this . mode ) { 
this . getAncestorClient = new SQLUtilWebSocketGetAncestorClient ( 
this . baseURL , 
this . loggedInUser . getServiceTicketAsHexUpper ( ) , 
this . timeoutMillis , 
COMPRESS_RSP , 
COMPRESS_RSP_CHARSET ) ; 
this . mode = Mode . WebSocketActive ; 
} catch ( FluidClientException clientExcept ) { 
if ( clientExcept . getErrorCode ( ) != 
FluidClientException . ErrorCode . WEB_SOCKET_DEPLOY_ERROR ) { 
throw clientExcept ; 
Form formToUse = ( formToGetAncestorForParam == null ) ? null : 
new Form ( formToGetAncestorForParam . getId ( ) ) ; 
return ( this . getAncestorClient == null ) ? 
this . sqlUtilClient . getAncestor ( 
formToUse , 
includeTableFieldsParam ) : 
this . getAncestorClient . getAncestorSynchronized ( formToUse ) ; 
} public List < FormListing > getDescendants ( 
boolean includeTableFieldFormRecordInfoParam , 
boolean massFetchParam , 
Form ... formsToGetDescForParam ) 
if ( this . getDescendantsClient == null && Mode . RESTfulActive != this . mode ) { 
this . getDescendantsClient = new SQLUtilWebSocketGetDescendantsClient ( 
includeTableFieldFormRecordInfoParam , 
massFetchParam , 
if ( formsToGetDescForParam == null || formsToGetDescForParam . length < 1 ) { 
Form [ ] formsToFetchFor = 
new Form [ formsToGetDescForParam . length ] ; 
for ( int index = 0 ; index < formsToFetchFor . length ; index ++ ) { 
formsToFetchFor [ index ] = new Form ( formsToGetDescForParam [ index ] . getId ( ) ) ; 
if ( this . getDescendantsClient != null ) { 
return this . getDescendantsClient . getDescendantsSynchronized ( 
formsToFetchFor ) ; 
List < FormListing > returnVal = new ArrayList < > ( ) ; 
for ( Form formToFetchFor : formsToFetchFor ) { 
List < Form > listOfForms = 
this . sqlUtilClient . getDescendants ( 
formToFetchFor , 
FormListing toAdd = new FormListing ( ) ; 
toAdd . setListing ( listOfForms ) ; 
toAdd . setListingCount ( ( listOfForms == null ) ? 0 : listOfForms . size ( ) ) ; 
returnVal . add ( toAdd ) ; 
} public List < FormListing > getTableForms ( 
Form ... formsToGetTableFormsForParam 
if ( this . getTableFormsClient == null && 
this . getTableFormsClient = new SQLUtilWebSocketGetTableFormsClient ( 
if ( formsToGetTableFormsForParam == null || formsToGetTableFormsForParam . length < 1 ) { 
new Form [ formsToGetTableFormsForParam . length ] ; 
formsToFetchFor [ index ] = new Form ( formsToGetTableFormsForParam [ index ] . getId ( ) ) ; 
if ( this . getTableFormsClient != null ) { 
return this . getTableFormsClient . getTableFormsSynchronized ( formsToFetchFor ) ; 
this . sqlUtilClient . getTableForms ( 
includeFieldDataParam ) ; 
} public List < FormFieldListing > getFormFields ( 
Form ... formsToGetFieldsForParam 
if ( this . getFormFieldsClient == null && Mode . RESTfulActive != this . mode ) { 
this . getFormFieldsClient = new SQLUtilWebSocketGetFormFieldsClient ( 
if ( formsToGetFieldsForParam == null || 
formsToGetFieldsForParam . length < 1 ) { 
new Form [ formsToGetFieldsForParam . length ] ; 
formsToFetchFor [ index ] = new Form ( formsToGetFieldsForParam [ index ] . getId ( ) ) ; 
if ( this . getFormFieldsClient != null ) { 
return this . getFormFieldsClient . getFormFieldsSynchronized ( 
List < FormFieldListing > returnVal = new ArrayList < > ( ) ; 
List < Field > listOfFields = 
this . sqlUtilClient . getFormFields ( 
FormFieldListing toAdd = new FormFieldListing ( ) ; 
toAdd . setListing ( listOfFields ) ; 
toAdd . setListingCount ( ( listOfFields == null ) ? 0 : listOfFields . size ( ) ) ; 
} public void massPopulateFormFields ( 
Form ... formsToPopulateFormFieldsForParam 
if ( formsToPopulateFormFieldsForParam == null || 
formsToPopulateFormFieldsForParam . length < 1 ) { 
Form [ ] formsToFetchForLocalCacheArr = 
new Form [ formsToPopulateFormFieldsForParam . length ] ; 
for ( int index = 0 ; index < formsToFetchForLocalCacheArr . length ; index ++ ) { 
formsToFetchForLocalCacheArr [ index ] = new Form ( formsToPopulateFormFieldsForParam [ index ] . getId ( ) ) ; 
formsToFetchForLocalCacheArr [ index ] . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
List < FormFieldListing > listingReturnFieldValsPopulated = new ArrayList < > ( ) ; 
listingReturnFieldValsPopulated = 
this . getFormFieldsClient . getFormFieldsSynchronized ( formsToFetchForLocalCacheArr ) ; 
for ( Form formToFetchFor : formsToFetchForLocalCacheArr ) { 
toAdd . setEcho ( formToFetchFor . getEcho ( ) ) ; 
listingReturnFieldValsPopulated . add ( toAdd ) ; 
for ( Form formToSetFieldsOn : formsToPopulateFormFieldsForParam ) { 
formToSetFieldsOn . setFormFields ( 
this . getFieldValuesForFormFromCache ( 
formToSetFieldsOn . getId ( ) , 
listingReturnFieldValsPopulated , 
formsToFetchForLocalCacheArr ) ) ; 
} private List < Field > getFieldValuesForFormFromCache ( 
Long formIdParam , 
List < FormFieldListing > listingReturnFieldValsPopulatedParam , 
Form [ ] formsToFetchForLocalCacheArrParam ) { 
if ( formIdParam == null || formIdParam . longValue ( ) < 1 ) { 
if ( listingReturnFieldValsPopulatedParam == null || 
listingReturnFieldValsPopulatedParam . isEmpty ( ) ) { 
if ( formsToFetchForLocalCacheArrParam == null || 
formsToFetchForLocalCacheArrParam . length == 0 ) { 
for ( Form formIter : formsToFetchForLocalCacheArrParam ) { 
if ( formIdParam . equals ( formIter . getId ( ) ) ) { 
String echoToUse = formIter . getEcho ( ) ; 
for ( FormFieldListing fieldListing : listingReturnFieldValsPopulatedParam ) { 
if ( echoToUse . equals ( fieldListing . getEcho ( ) ) ) { 
return fieldListing . getListing ( ) ; 
} public void closeAndClean ( ) { 
if ( this . sqlUtilClient != null ) { 
this . sqlUtilClient . closeAndClean ( ) ; 
if ( this . getAncestorClient != null ) { 
this . getAncestorClient . closeAndClean ( ) ; 
this . getDescendantsClient . closeAndClean ( ) ; 
this . getTableFormsClient . closeAndClean ( ) ; 
this . getFormFieldsClient . closeAndClean ( ) ; 
if ( this . getColumnName ( ) != null ) 
returnVal . put ( JSONMapping . COLUMN_NAME , 
this . getColumnName ( ) ) ; 
if ( this . getColumnIndex ( ) != null ) 
returnVal . put ( JSONMapping . COLUMN_INDEX , 
this . getColumnIndex ( ) ) ; 
if ( this . getSqlType ( ) != null ) 
JSONMapping . SQL_TYPE , this . getSqlType ( ) ) ; 
if ( this . getSqlValue ( ) != null ) 
returnVal . put ( JSONMapping . SQL_VALUE , 
this . getSqlValue ( ) ) ; 
if ( this . getId ( ) != null ) 
returnVal . put ( JSONMapping . ID , this . getId ( ) ) ; 
if ( this . getServiceTicket ( ) != null ) 
returnVal . put ( JSONMapping . SERVICE_TICKET , this . getServiceTicket ( ) ) ; 
if ( this . getEcho ( ) != null ) 
returnVal . put ( JSONMapping . ECHO , this . getEcho ( ) ) ; 
private Date getLongAsDateFromJson ( Long longValueParam ) 
if ( longValueParam == null ) 
return new Date ( longValueParam ) ; 
public Date getDateFieldValueFromFieldWithName ( String fieldNameParam ) 
if ( ( fieldNameParam == null || fieldNameParam . trim ( ) . isEmpty ( ) ) || 
( this . jsonObject == null || this . jsonObject . isNull ( fieldNameParam ) ) ) 
Object objectAtIndex = this . jsonObject . get ( fieldNameParam ) ; 
if ( objectAtIndex instanceof Number ) 
return this . getLongAsDateFromJson ( ( ( Number ) objectAtIndex ) . longValue ( ) ) ; 
else if ( objectAtIndex instanceof String ) 
Date validDate = null ; 
for ( SimpleDateFormat format : SUPPORTED_FORMATS ) 
validDate = format . parse ( ( String ) objectAtIndex ) ; 
if ( validDate != null ) 
catch ( ParseException parseExcept ) 
validDate = null ; 
return validDate ; 
public Long getDateAsLongFromJson ( Date dateValueParam ) 
if ( dateValueParam == null ) 
return dateValueParam . getTime ( ) ; 
} public FlowStepRule createFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) 
if ( flowStepRuleParam != null && this . serviceTicket != null ) 
flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . putJson ( 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleEntryCreate ( ) ) ) ; 
} public FlowStepRule createFlowStepExitRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleExitCreate ( ) ) ) ; 
} public FlowStepRule createFlowStepViewRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleViewCreate ( ) ) ) ; 
} public FlowStepRule updateFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) 
return new FlowStepRule ( this . postJson ( 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateEntry ( ) ) ) ; 
} public FlowStepRule updateFlowStepExitRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateExit ( ) ) ) ; 
} public FlowStepRule updateFlowStepViewRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateView ( ) ) ) ; 
} public FlowStepRule compileFlowStepViewRule ( String viewRuleSyntaxParam ) 
FlowStepRule flowStepRule = new FlowStepRule ( ) ; 
flowStepRule . setRule ( viewRuleSyntaxParam ) ; 
flowStepRule . setServiceTicket ( this . serviceTicket ) ; 
flowStepRule , WS . Path . FlowStepRule . Version1 . compileViewSyntax ( ) ) ) ; 
} public FlowStepRuleListing getExitRulesByStep ( FlowStep flowStepParam ) 
if ( flowStepParam == null ) 
return new FlowStepRuleListing ( this . postJson ( 
flowStepParam , WS . Path . FlowStepRule . Version1 . getExitRulesByStep ( ) ) ) ; 
} public FlowItemExecuteResult compileFlowStepViewRuleAndExecute ( 
String viewRuleSyntaxParam , FluidItem fluidItemToExecuteOnParam ) 
FlowItemExecutePacket toPost = new FlowItemExecutePacket ( ) ; 
toPost . setServiceTicket ( this . serviceTicket ) ; 
toPost . setFlowStepRule ( flowStepRule ) ; 
toPost . setFluidItem ( fluidItemToExecuteOnParam ) ; 
return new FlowItemExecuteResult ( this . postJson ( 
toPost , WS . Path . FlowStepRule . Version1 . compileViewSyntaxAndExecute ( ) ) ) ; 
} public FlowStepRule compileFlowStepEntryRule ( String entryRuleSyntaxParam ) 
flowStepRule . setRule ( entryRuleSyntaxParam ) ; 
flowStepRule , WS . Path . FlowStepRule . Version1 . compileEntrySyntax ( ) ) ) ; 
} public FlowItemExecuteResult compileFlowStepEntryRuleAndExecute ( 
String entryRuleSyntaxParam , FluidItem fluidItemToExecuteOnParam ) 
toPost , WS . Path . FlowStepRule . Version1 . compileEntrySyntaxAndExecute ( ) ) ) ; 
} public FlowStepRule moveFlowStepEntryRuleUp ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryUp ( ) ) ) ; 
} public FlowStepRule moveFlowStepEntryRuleDown ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryDown ( ) ) ) ; 
} public FlowStepRule deleteFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteEntry ( ) ) ) ; 
} public FlowStep deleteFlowStepExitRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteExit ( ) ) ) ; 
} public FlowStep deleteFlowStepViewRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteView ( ) ) ) ; 
} public List < String > getNextValidSyntaxWordsEntryRule ( String inputRuleParam ) 
if ( inputRuleParam == null ) 
inputRuleParam = UtilGlobal . EMPTY ; 
flowStepRule . setRule ( inputRuleParam ) ; 
FlowStepRule returnedObj = new FlowStepRule ( this . postJson ( 
flowStepRule , WS . Path . FlowStepRule . Version1 . getNextValidEntrySyntax ( ) ) ) ; 
return returnedObj . getNextValidSyntaxWords ( ) ; 
} public AppRequestToken login ( 
String usernameParam , String passwordParam ) { 
return this . login ( usernameParam , passwordParam , TimeUnit . HOURS . toSeconds ( 9 ) ) ; 
String usernameParam , String passwordParam , Long sessionLifespanSecondsParam ) { 
if ( this . isEmpty ( usernameParam ) || this . isEmpty ( passwordParam ) ) { 
AuthRequest authRequest = new AuthRequest ( ) ; 
authRequest . setUsername ( usernameParam ) ; 
authRequest . setLifetime ( sessionLifespanSecondsParam ) ; 
AuthResponse authResponse ; 
authResponse = new AuthResponse ( 
this . postJson ( 
authRequest , 
WS . Path . User . Version1 . userInitSession ( ) ) ) ; 
catch ( JSONException jsonException ) { 
jsonException . getMessage ( ) , jsonException , FluidClientException . ErrorCode . JSON_PARSING ) ; 
AuthEncryptedData authEncData = 
this . initializeSession ( passwordParam , authResponse ) ; 
AppRequestToken appReqToken = this . issueAppRequestToken ( 
authResponse . getServiceTicketBase64 ( ) , 
usernameParam , authEncData ) ; 
appReqToken . setRoleString ( authEncData . getRoleListing ( ) ) ; 
appReqToken . setSalt ( authResponse . getSalt ( ) ) ; 
return appReqToken ; 
} private AuthEncryptedData initializeSession ( 
String passwordParam , 
AuthResponse authResponseParam ) { 
byte [ ] ivBytes = UtilGlobal . decodeBase64 ( 
authResponseParam . getIvBase64 ( ) ) ; 
byte [ ] seedBytes = UtilGlobal . decodeBase64 ( 
authResponseParam . getSeedBase64 ( ) ) ; 
byte [ ] encryptedData = UtilGlobal . decodeBase64 ( 
authResponseParam . getEncryptedDataBase64 ( ) ) ; 
byte [ ] hMacFromResponse = UtilGlobal . decodeBase64 ( 
authResponseParam . getEncryptedDataHmacBase64 ( ) ) ; 
byte [ ] localGeneratedHMac = AES256Local . generateLocalHMAC ( 
encryptedData , passwordParam , authResponseParam . getSalt ( ) , seedBytes ) ; 
if ( ! Arrays . equals ( hMacFromResponse , localGeneratedHMac ) ) { 
FluidClientException . ErrorCode . LOGIN_FAILURE ) ; 
byte [ ] decryptedEncryptedData = 
AES256Local . decryptInitPacket ( encryptedData , 
passwordParam , 
authResponseParam . getSalt ( ) , 
ivBytes , 
seedBytes ) ; 
JSONObject jsonObj = new JSONObject ( new String ( decryptedEncryptedData ) ) ; 
return new AuthEncryptedData ( jsonObj ) ; 
} private AppRequestToken issueAppRequestToken ( 
String serviceTicketBase64Param , 
String usernameParam , 
AuthEncryptedData authEncryptDataParam ) 
byte [ ] iv = AES256Local . generateRandom ( AES256Local . IV_SIZE_BYTES ) ; 
byte [ ] seed = AES256Local . generateRandom ( AES256Local . SEED_SIZE_BYTES ) ; 
byte [ ] sessionKey = UtilGlobal . decodeBase64 ( 
authEncryptDataParam . getSessionKeyBase64 ( ) ) ; 
byte [ ] dataToEncrypt = usernameParam . getBytes ( ) ; 
byte [ ] encryptedData = AES256Local . encrypt ( 
sessionKey , 
dataToEncrypt , 
iv ) ; 
byte [ ] encryptedDataHMac = 
AES256Local . generateLocalHMACForReqToken ( encryptedData , sessionKey , seed ) ; 
AppRequestToken requestToServer = new AppRequestToken ( ) ; 
requestToServer . setEncryptedDataBase64 ( UtilGlobal . encodeBase64 ( encryptedData ) ) ; 
requestToServer . setEncryptedDataHmacBase64 ( UtilGlobal . encodeBase64 ( encryptedDataHMac ) ) ; 
requestToServer . setIvBase64 ( UtilGlobal . encodeBase64 ( iv ) ) ; 
requestToServer . setSeedBase64 ( UtilGlobal . encodeBase64 ( seed ) ) ; 
requestToServer . setServiceTicket ( serviceTicketBase64Param ) ; 
return new AppRequestToken ( 
this . postJson ( requestToServer , WS . Path . User . Version1 . userIssueToken ( ) ) ) ; 
if ( this . getAssignmentRuleValue ( ) != null ) 
returnVal . put ( JSONMapping . ASSIGNMENT_RULE_VALUE , 
this . getAssignmentRuleValue ( ) ) ; 
if ( this . getStatementResultAsString ( ) != null ) 
returnVal . put ( JSONMapping . STATEMENT_RESULT_AS_STRING , 
this . getStatementResultAsString ( ) ) ; 
if ( this . getExecutePerFluidItemQuery ( ) != null ) 
returnVal . put ( JSONMapping . EXECUTE_PER_FLUID_ITEM_QUERY , 
this . getExecutePerFluidItemQuery ( ) ) ; 
if ( this . getFluidItemQuery ( ) != null ) 
returnVal . put ( JSONMapping . FLUID_ITEM_QUERY , 
this . getFluidItemQuery ( ) ) ; 
if ( this . getExecutionResult ( ) != null ) 
returnVal . put ( JSONMapping . EXECUTION_RESULT , 
this . getExecutionResult ( ) ) ; 
if ( this . getProgressToNextPhase ( ) != null ) 
returnVal . put ( JSONMapping . PROGRESS_TO_NEXT_PHASE , 
this . getProgressToNextPhase ( ) ) ; 
if ( this . getFluidItems ( ) != null && ! this . getFluidItems ( ) . isEmpty ( ) ) 
for ( FluidItem item : this . getFluidItems ( ) ) 
jsonArray . put ( item . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FLUID_ITEMS , jsonArray ) ; 
if ( this . getExecuteUsers ( ) != null && ! this . getExecuteUsers ( ) . isEmpty ( ) ) 
for ( User item : this . getExecuteUsers ( ) ) 
returnVal . put ( JSONMapping . EXECUTE_USERS , jsonArray ) ; 
if ( this . getMailMessagesToSend ( ) != null && 
! this . getMailMessagesToSend ( ) . isEmpty ( ) ) 
for ( MailMessage item : this . getMailMessagesToSend ( ) ) 
returnVal . put ( JSONMapping . MAIL_MESSAGES_TO_SEND , jsonArray ) ; 
if ( this . getAvailableMultiChoices ( ) != null ) { 
List < String > availChoices = this . getAvailableMultiChoices ( ) ; 
returnVal . put ( JSONMapping . AVAILABLE_MULTI_CHOICES , 
new JSONArray ( availChoices . toArray ( ) ) ) ; 
returnVal . put ( JSONMapping . AVAILABLE_CHOICES , 
JSONMapping . AVAILABLE_CHOICES_COMBINED , 
this . combineStringArrayWith ( 
availChoices , 
UtilGlobal . PIPE ) ) ; 
if ( this . getSelectedMultiChoices ( ) != null ) { 
List < String > selectChoices = this . getSelectedMultiChoices ( ) ; 
returnVal . put ( JSONMapping . SELECTED_MULTI_CHOICES , 
new JSONArray ( selectChoices . toArray ( ) ) ) ; 
returnVal . put ( JSONMapping . SELECTED_CHOICES , 
JSONMapping . SELECTED_CHOICES_COMBINED , 
selectChoices , 
public String combineStringArrayWith ( 
List < String > listToCombineParam , 
String separatorCharsParam ) { 
String returnValue = UtilGlobal . EMPTY ; 
int lengthOfSepChars = ( separatorCharsParam == null ) ? 0 : 
separatorCharsParam . length ( ) ; 
if ( listToCombineParam != null && ! listToCombineParam . isEmpty ( ) ) { 
StringBuffer concatBuffer = new StringBuffer ( ) ; 
for ( String toAdd : listToCombineParam ) { 
concatBuffer . append ( toAdd ) ; 
concatBuffer . append ( separatorCharsParam ) ; 
String concatString = concatBuffer . toString ( ) ; 
returnValue = concatString . substring ( 0 , concatString . length ( ) - lengthOfSepChars ) ; 
} public UserQuery createUserQuery ( UserQuery userQueryParam ) 
if ( userQueryParam != null && this . serviceTicket != null ) 
userQueryParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserQuery ( this . putJson ( 
userQueryParam , 
WS . Path . UserQuery . Version1 . userQueryCreate ( ) ) ) ; 
} public UserQuery updateUserQuery ( UserQuery userQueryParam ) { 
if ( userQueryParam != null && this . serviceTicket != null ) { 
return new UserQuery ( this . postJson ( 
WS . Path . UserQuery . Version1 . userQueryUpdate ( ) ) ) ; 
} public UserQuery deleteUserQuery ( 
UserQuery userQueryToDeleteParam 
if ( userQueryToDeleteParam != null && this . serviceTicket != null ) { 
userQueryToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserQuery ( this . postJson ( userQueryToDeleteParam , 
WS . Path . UserQuery . Version1 . userQueryDelete ( ) ) ) ; 
} public UserQuery getUserQueryById ( Long userQueryIdParam ) { 
UserQuery userQueryToGetInfoFor = new UserQuery ( ) ; 
userQueryToGetInfoFor . setId ( userQueryIdParam ) ; 
userQueryToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
userQueryToGetInfoFor , WS . Path . UserQuery . Version1 . getById ( ) ) ) ; 
} public UserQueryListing getAllUserQueries ( ) { 
return new UserQueryListing ( this . postJson ( 
userQueryToGetInfoFor , WS . Path . UserQuery . Version1 . getAllUserQueries ( ) ) ) ; 
} public FluidItemListing executeUserQuery ( 
UserQuery queryToExecuteParam , 
boolean populateAncestorIdParam , 
int queryLimitParam , 
int offsetParam 
return this . executeUserQuery ( 
queryToExecuteParam , 
populateAncestorIdParam , 
queryLimitParam , 
boolean forceUseDatabaseParam 
if ( this . serviceTicket != null && queryToExecuteParam != null ) { 
queryToExecuteParam . setServiceTicket ( this . serviceTicket ) ; 
queryToExecuteParam , WS . Path . UserQuery . Version1 . executeUserQuery ( 
forceUseDatabaseParam , 
offsetParam ) ) ) ; 
} public List < FormFieldMapping > getFormFieldMappingForForm ( 
Long electronicFormIdParam ) 
List < FormFieldMapping > returnVal = new ArrayList ( ) ; 
if ( electronicFormIdParam == null ) 
Long formDefinitionId = this . getFormDefinitionId ( electronicFormIdParam ) ; 
if ( this . localDefinitionToFieldsMapping . containsKey ( formDefinitionId ) ) 
return this . localDefinitionToFieldsMapping . get ( formDefinitionId ) ; 
ISyntax . ProcedureMapping . Field . GetFormFieldsForFormContainer ) ; 
returnVal . add ( this . mapFormFieldMapping ( resultSet ) ) ; 
this . localDefinitionToFieldsMapping . put ( formDefinitionId , returnVal ) ; 
} public List < FormFieldMapping > getFormFieldMappingForFormDefinition ( 
Long formDefinitionIdParam 
if ( formDefinitionIdParam == null || formDefinitionIdParam . longValue ( ) < 1 ) 
if ( this . localDefinitionToFieldsMapping . containsKey ( formDefinitionIdParam ) ) 
return this . localDefinitionToFieldsMapping . get ( formDefinitionIdParam ) ; 
ISyntax . ProcedureMapping . Field . GetFormFieldsForFormDefinition ) ; 
preparedStatement . setLong ( 1 , formDefinitionIdParam ) ; 
this . localDefinitionToFieldsMapping . put ( formDefinitionIdParam , returnVal ) ; 
catch ( SQLException sqlError ) { 
} public Long getFormDefinitionId ( Long electronicFormIdParam ) 
ResultSet resultSet ; 
ISyntax . ProcedureMapping . Field . GetFormDefinitionForFormContainer ) ; 
return resultSet . getLong ( 1 ) ; 
this . closeStatement ( preparedStatement ) ; 
boolean includeTableFieldFormRecordInfoParam 
List < Field > returnVal = new ArrayList ( ) ; 
List < FormFieldMapping > fieldMappings = 
this . getFormFieldMappingForForm ( electronicFormIdParam ) ; 
if ( fieldMappings == null || fieldMappings . isEmpty ( ) ) { 
for ( FormFieldMapping fieldMapping : fieldMappings ) { 
if ( ! includeTableFieldsParam && 
fieldMapping . dataType == UtilGlobal . FieldTypeId . _7_TABLE_FIELD ) { 
Field fieldToAdd = this . getFormFieldValueFor ( 
fieldMapping , 
electronicFormIdParam , 
if ( fieldToAdd == null ) { 
if ( includeTableFieldsParam && ( fieldToAdd . getFieldValue ( ) instanceof TableField ) ) { 
TableField tableField = ( TableField ) fieldToAdd . getFieldValue ( ) ; 
if ( tableField . getTableRecords ( ) != null && ! tableField . getTableRecords ( ) . isEmpty ( ) ) { 
for ( Form tableRecordForm : tableField . getTableRecords ( ) ) { 
tableRecordForm . setFormFields ( 
this . getFormFields ( 
tableRecordForm . getId ( ) , 
returnVal . add ( fieldToAdd ) ; 
} public Field getFormFieldValueFor ( 
FormFieldMapping formFieldMappingParam , 
Long formContainerIdParam , 
if ( formFieldMappingParam == null ) { 
if ( this . getCacheUtil ( ) != null ) { 
CacheUtil . CachedFieldValue cachedFieldValue = 
this . getCacheUtil ( ) . getCachedFieldValueFrom ( 
formFieldMappingParam . formDefinitionId , 
formContainerIdParam , 
formFieldMappingParam . formFieldId ) ; 
if ( cachedFieldValue != null ) 
Field field = cachedFieldValue . getCachedFieldValueAsField ( ) ; 
if ( field != null ) 
field . setFieldName ( formFieldMappingParam . name ) ; 
Field returnVal = null ; 
PreparedStatement preparedStatement = null , preparedStatementForTblInfo = null ; 
ResultSet resultSet = null , resultSetForTblInfo = null ; 
ISyntax syntax = SyntaxFactory . getInstance ( ) . getFieldValueSyntaxFor ( 
formFieldMappingParam ) ; 
if ( syntax != null ) { 
preparedStatement . setLong ( 1 , formFieldMappingParam . formDefinitionId ) ; 
preparedStatement . setLong ( 2 , formFieldMappingParam . formFieldId ) ; 
preparedStatement . setLong ( 3 , formContainerIdParam ) ; 
switch ( formFieldMappingParam . dataType . intValue ( ) ) { 
case UtilGlobal . FieldTypeId . _1_TEXT : 
returnVal = new Field ( 
formFieldMappingParam . name , 
resultSet . getString ( 1 ) , 
Field . Type . Text ) ; 
case UtilGlobal . FieldTypeId . _2_TRUE_FALSE : 
resultSet . getBoolean ( 1 ) , 
Field . Type . TrueFalse ) ; 
case UtilGlobal . FieldTypeId . _3_PARAGRAPH_TEXT : 
Field . Type . ParagraphText ) ; 
case UtilGlobal . FieldTypeId . _4_MULTI_CHOICE : 
List < String > selectedValues = new ArrayList ( ) ; 
while ( resultSet . next ( ) ) { 
selectedValues . add ( resultSet . getString ( 1 ) ) ; 
multiChoice . setSelectedMultiChoices ( selectedValues ) ; 
if ( ! selectedValues . isEmpty ( ) ) { 
multiChoice ) ; 
case UtilGlobal . FieldTypeId . _5_DATE_TIME : 
resultSet . getDate ( 1 ) , 
Field . Type . DateTime ) ; 
case UtilGlobal . FieldTypeId . _6_DECIMAL : 
resultSet . getDouble ( 1 ) , 
Field . Type . Decimal ) ; 
case UtilGlobal . FieldTypeId . _7_TABLE_FIELD : 
List < Long > formContainerIds = new ArrayList ( ) ; 
formContainerIds . add ( resultSet . getLong ( 1 ) ) ; 
if ( formContainerIds . isEmpty ( ) ) { 
TableField tableField = new TableField ( ) ; 
final List < Form > formRecords = new ArrayList ( ) ; 
formContainerIds . forEach ( formContId -> { 
formRecords . add ( new Form ( formContId ) ) ; 
if ( includeTableFieldFormRecordInfoParam ) { 
ISyntax syntaxForFormContInfo = SyntaxFactory . getInstance ( ) . getSyntaxFor ( 
ISyntax . ProcedureMapping . Form . GetFormContainerInfo ) ; 
preparedStatementForTblInfo = this . getConnection ( ) . prepareStatement ( 
syntaxForFormContInfo . getPreparedStatement ( ) ) ; 
for ( Form formRecordToSetInfoOn : formRecords ) { 
preparedStatementForTblInfo . setLong ( 
1 , formRecordToSetInfoOn . getId ( ) ) ; 
resultSetForTblInfo = preparedStatementForTblInfo . executeQuery ( ) ; 
if ( resultSetForTblInfo . next ( ) ) { 
Long formTypeId = resultSetForTblInfo . getLong ( 
SQLFormUtil . SQLColumnIndex . _02_FORM_TYPE ) ; 
formRecordToSetInfoOn . setFormTypeId ( formTypeId ) ; 
formRecordToSetInfoOn . setFormType ( 
this . sqlFormDefinitionUtil == null ? null : 
this . sqlFormDefinitionUtil . getFormDefinitionIdAndTitle ( ) . get ( formTypeId ) 
formRecordToSetInfoOn . setTitle ( resultSetForTblInfo . getString ( 
SQLFormUtil . SQLColumnIndex . _03_TITLE ) ) ; 
Date created = resultSetForTblInfo . getDate ( SQLFormUtil . SQLColumnIndex . _04_CREATED ) ; 
Date lastUpdated = resultSetForTblInfo . getDate ( SQLFormUtil . SQLColumnIndex . _05_LAST_UPDATED ) ; 
if ( created != null ) 
formRecordToSetInfoOn . setDateCreated ( new Date ( created . getTime ( ) ) ) ; 
if ( lastUpdated != null ) 
formRecordToSetInfoOn . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; 
tableField . setTableRecords ( formRecords ) ; 
tableField , 
Field . Type . Table ) ; 
case UtilGlobal . FieldTypeId . _9_LABEL : 
formFieldMappingParam . description , 
Field . Type . Label ) ; 
this . closeStatement ( preparedStatementForTblInfo ) ; 
} private FormFieldMapping mapFormFieldMapping ( ResultSet resultSetParam ) 
throws SQLException { 
return new FormFieldMapping ( 
resultSetParam . getLong ( 1 ) , 
resultSetParam . getLong ( 2 ) , 
resultSetParam . getLong ( 3 ) , 
resultSetParam . getString ( 4 ) , 
resultSetParam . getString ( 5 ) , 
resultSetParam . getString ( 6 ) ) ; 
} public Role createRole ( Role roleParam ) 
if ( roleParam != null && this . serviceTicket != null ) 
return new Role ( this . putJson ( 
roleParam , WS . Path . Role . Version1 . roleCreate ( ) ) ) ; 
} public Role updateRole ( Role roleParam ) 
return new Role ( this . postJson ( 
roleParam , WS . Path . Role . Version1 . roleUpdate ( ) ) ) ; 
} public Role deleteRole ( 
Role roleToDeleteParam ) 
if ( roleToDeleteParam != null && this . serviceTicket != null ) 
roleToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new Role ( this . postJson ( roleToDeleteParam , 
WS . Path . Role . Version1 . roleDelete ( ) ) ) ; 
} public Role getRoleById ( Long roleIdParam ) 
Role roleToGetInfoFor = new Role ( ) ; 
roleToGetInfoFor . setId ( roleIdParam ) ; 
roleToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
roleToGetInfoFor , WS . Path . Role . Version1 . getById ( ) ) ) ; 
} public RoleListing getAllRoles ( ) 
RoleListing roleToGetInfoFor = new RoleListing ( ) ; 
return new RoleListing ( this . postJson ( 
roleToGetInfoFor , WS . Path . Role . Version1 . getAllRoles ( ) ) ) ; 
if ( this . getAttachmentPath ( ) != null ) 
returnVal . put ( JSONMapping . ATTACHMENT_PATH , 
this . getAttachmentPath ( ) ) ; 
if ( this . getAttachmentDataBase64 ( ) != null ) 
} public CommandResult executeCommand ( String ... commandParams ) throws IOException { 
if ( commandParams == null || commandParams . length == 0 ) { 
List < String > returnedLines = new ArrayList ( ) ; 
Charset charset = Charset . forName ( ENCODING_UTF_8 ) ; 
Process process = null ; 
if ( commandParams . length == 1 ) { 
process = Runtime . getRuntime ( ) . exec ( commandParams [ 0 ] ) ; 
process = Runtime . getRuntime ( ) . exec ( commandParams ) ; 
BufferedReader reader = new BufferedReader ( 
new InputStreamReader ( 
process . getInputStream ( ) , charset ) ) ; 
String readLine = null ; 
while ( ( readLine = reader . readLine ( ) ) != null ) { 
returnedLines . add ( readLine ) ; 
BufferedReader errorReader = new BufferedReader ( 
new InputStreamReader ( process . getErrorStream ( ) , charset ) ) ; 
while ( ( readLine = errorReader . readLine ( ) ) != null ) { 
int exitValue = - 1000 ; 
exitValue = process . waitFor ( ) ; 
String commandString = ( commandParams == null || commandParams . length == 0 ) ? 
"<unknown>" : commandParams [ 0 ] ; 
String [ ] rtnArr = { } ; 
return new CommandResult ( exitValue , returnedLines . toArray ( rtnArr ) ) ; 
} catch ( IOException ioExeption ) { 
} public CommandResult executeCommand ( String objectCommandParam ) throws Exception { 
if ( objectCommandParam == null ) { 
return new CommandResult ( 333 , new String [ ] { 
return this . executeCommand ( new String [ ] { objectCommandParam } ) ; 
if ( this . getAccessToken ( ) != null ) 
returnVal . put ( JSONMapping . ACCESS_TOKEN , this . getAccessToken ( ) ) ; 
if ( this . getIdToken ( ) != null ) 
returnVal . put ( JSONMapping . ID_TOKEN , this . getIdToken ( ) ) ; 
if ( this . getTokenType ( ) != null ) 
returnVal . put ( JSONMapping . TOKEN_TYPE , this . getTokenType ( ) ) ; 
if ( this . getDate ( ) != null ) { 
returnVal . put ( JSONMapping . DATE , 
this . getDateAsLongFromJson ( this . getDate ( ) ) ) ; 
if ( this . getDateAndFieldName ( ) != null ) { 
returnVal . put ( JSONMapping . DATE_AND_FIELD_NAME , 
this . getDateAndFieldName ( ) ) ; 
if ( this . getFormContainerFieldValuesJSON ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_CONTAINER_FIELD_VALUES_JSON , 
this . getFormContainerFieldValuesJSON ( ) ) ; 
if ( this . getLogEntryType ( ) != null ) { 
returnVal . put ( JSONMapping . LOG_ENTRY_TYPE , 
this . getLogEntryType ( ) ) ; 
if ( this . getDescription ( ) != null ) { 
returnVal . put ( JSONMapping . DESCRIPTION , 
this . getDescription ( ) ) ; 
if ( this . getHistoricEntryType ( ) != null ) { 
returnVal . put ( JSONMapping . HISTORIC_ENTRY_TYPE , 
this . getHistoricEntryType ( ) ) ; 
if ( this . getUser ( ) != null ) { 
returnVal . put ( JSONMapping . USER , 
this . getUser ( ) . toJsonObject ( ) ) ; 
if ( this . getField ( ) != null ) { 
returnVal . put ( JSONMapping . FIELD , 
this . getField ( ) . toJsonObject ( ) ) ; 
if ( this . getIsFieldDifferentFromPrevious ( ) != null ) { 
returnVal . put ( JSONMapping . IS_FIELD_DIFFERENT_FROM_PREVIOUS , 
this . getIsFieldDifferentFromPrevious ( ) ) ; 
if ( this . getIsFieldTypeSignature ( ) != null ) { 
returnVal . put ( JSONMapping . IS_FIELD_TYPE_SIGNATURE , 
this . getIsFieldTypeSignature ( ) ) ; 
if ( this . getIsEscapeText ( ) != null ) { 
JSONMapping . IS_ESCAPE_TEXT , 
this . getIsEscapeText ( ) ) ; 
if ( this . isAttachmentsView ( ) != null ) 
returnVal . put ( JSONMapping . ATTACHMENTS_VIEW , 
this . isAttachmentsView ( ) . booleanValue ( ) ) ; 
if ( this . isAttachmentsCreateUpdate ( ) != null ) 
returnVal . put ( JSONMapping . ATTACHMENTS_CREATE_UPDATE , 
this . isAttachmentsCreateUpdate ( ) . booleanValue ( ) ) ; 
public Object getFieldValueForField ( String fieldNameParam ) { 
Field fieldWithName = this . getField ( fieldNameParam ) ; 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValue ( ) ; 
public String getFieldValueAsString ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsString ( ) ; 
public TableField getFieldValueAsTableField ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsTableField ( ) ; 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsMultiChoice ( ) ; 
public Date getFieldValueAsDate ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsDate ( ) ; 
public Boolean getFieldValueAsBoolean ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsBoolean ( ) ; 
public Double getFieldValueAsDouble ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsDouble ( ) ; 
public Integer getFieldValueAsInt ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsInteger ( ) ; 
public Long getFieldValueAsLong ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsLong ( ) ; 
public Number getFieldValueAsNumber ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsNumber ( ) ; 
public void setFieldValue ( String fieldNameParam , Object fieldValueParam ) { 
if ( fieldNameParam == null || fieldNameParam . trim ( ) . length ( ) == 0 ) 
if ( this . getFormFields ( ) == null || this . getFormFields ( ) . isEmpty ( ) ) 
this . setFormFields ( new ArrayList ( ) ) ; 
String fieldNameParamLower = fieldNameParam . toLowerCase ( ) ; 
for ( Iterator < Field > fieldIter = this . getFormFields ( ) . iterator ( ) ; 
fieldIter . hasNext ( ) ; ) { 
Field field = fieldIter . next ( ) ; 
if ( field . getFieldName ( ) == null || field . getFieldName ( ) . trim ( ) . length ( ) == 0 ) 
String fieldNameLower = field . getFieldName ( ) . toLowerCase ( ) ; 
if ( fieldNameParamLower . equals ( fieldNameLower ) ) 
field . setFieldValue ( fieldValueParam ) ; 
this . getFormFields ( ) . add ( new Field ( fieldNameParam , fieldValueParam ) ) ; 
public void setFieldValue ( String fieldNameParam , Object fieldValueParam , Field . Type typeParam ) { 
if ( fieldNameParam == null ) { 
if ( this . getFormFields ( ) == null || this . getFormFields ( ) . isEmpty ( ) ) { 
String paramLower = fieldNameParam . toLowerCase ( ) . trim ( ) ; 
boolean valueFound = false ; 
int fieldIndex = 0 ; 
fieldIter . hasNext ( ) ; fieldIndex ++ ) { 
String toCheckNameLower = field . getFieldName ( ) ; 
if ( toCheckNameLower == null || toCheckNameLower . trim ( ) . isEmpty ( ) ) { 
toCheckNameLower = toCheckNameLower . trim ( ) . toLowerCase ( ) ; 
if ( paramLower . equals ( toCheckNameLower ) ) { 
valueFound = true ; 
this . getFormFields ( ) . get ( fieldIndex ) . setFieldValue ( fieldValueParam ) ; 
this . getFormFields ( ) . get ( fieldIndex ) . setTypeAsEnum ( typeParam ) ; 
if ( ! valueFound ) { 
this . getFormFields ( ) . add ( new Field ( fieldNameParam , fieldValueParam , typeParam ) ) ; 
public boolean isFormType ( String formTypeParam ) { 
if ( ( formTypeParam == null || formTypeParam . trim ( ) . isEmpty ( ) ) || 
( this . getFormType ( ) == null || this . getFormType ( ) . trim ( ) . isEmpty ( ) ) ) { 
return formTypeParam . toLowerCase ( ) . equals ( getFormType ( ) . toLowerCase ( ) ) ; 
if ( this . getFormType ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_TYPE , this . getFormType ( ) ) ; 
if ( this . getFormTypeId ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_TYPE_ID , this . getFormTypeId ( ) ) ; 
if ( this . getTitle ( ) != null ) { 
returnVal . put ( JSONMapping . TITLE , this . getTitle ( ) ) ; 
if ( this . getFormDescription ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_DESCRIPTION , this . getFormDescription ( ) ) ; 
if ( this . getAncestorLabel ( ) != null ) { 
returnVal . put ( JSONMapping . ANCESTOR_LABEL , 
this . getAncestorLabel ( ) ) ; 
if ( this . getDescendantsLabel ( ) != null ) { 
returnVal . put ( JSONMapping . DESCENDANTS_LABEL , 
this . getDescendantsLabel ( ) ) ; 
if ( this . getNumberInputs ( ) != null ) { 
returnVal . put ( JSONMapping . NUMBER_INPUTS , 
this . getNumberInputs ( ) ) ; 
if ( this . getCurrentUser ( ) != null ) { 
JSONMapping . CURRENT_USER , 
this . getCurrentUser ( ) . toJsonObject ( ) ) ; 
if ( this . getState ( ) != null ) { 
JSONMapping . STATE , 
this . getState ( ) ) ; 
if ( this . getFlowState ( ) != null ) { 
JSONMapping . FLOW_STATE , 
this . getFlowState ( ) ) ; 
if ( this . getFormFields ( ) != null && ! this . getFormFields ( ) . isEmpty ( ) ) { 
JSONArray formFieldsArr = new JSONArray ( ) ; 
for ( Field toAdd : this . getFormFields ( ) ) 
formFieldsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FORM_FIELDS , formFieldsArr ) ; 
if ( this . getAssociatedFlows ( ) != null && ! this . getAssociatedFlows ( ) . isEmpty ( ) ) { 
JSONArray assoJobsArr = new JSONArray ( ) ; 
for ( Flow toAdd : this . getAssociatedFlows ( ) ) 
assoJobsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ASSOCIATED_FLOWS , assoJobsArr ) ; 
Long ancestorIdLcl = this . getAncestorId ( ) ; 
if ( ancestorIdLcl != null ) { 
returnVal . put ( JSONMapping . ANCESTOR_ID , ancestorIdLcl ) ; 
if ( this . getTableFieldParentId ( ) != null ) { 
returnVal . put ( JSONMapping . TABLE_FIELD_PARENT_ID , 
this . getTableFieldParentId ( ) ) ; 
if ( this . getDescendantIds ( ) != null && ! this . getDescendantIds ( ) . isEmpty ( ) ) { 
for ( Long formId : this . getDescendantIds ( ) ) { 
array . put ( formId ) ; 
returnVal . put ( JSONMapping . DESCENDANT_IDS , array ) ; 
JSONObject idJsonObj = new JSONObject ( ) ; 
idJsonObj . put ( 
Field . JSONMapping . Elastic . MAPPING_ONLY_TYPE , 
Field . ElasticSearchType . LONG ) ; 
returnVal . put ( ABaseFluidJSONObject . JSONMapping . ID , idJsonObj ) ; 
JSONObject formTypeJsonObj = new JSONObject ( ) ; 
formTypeJsonObj . put ( 
Field . ElasticSearchType . KEYWORD ) ; 
returnVal . put ( JSONMapping . FORM_TYPE , formTypeJsonObj ) ; 
JSONObject formTypeIdJsonObj = new JSONObject ( ) ; 
formTypeIdJsonObj . put ( 
returnVal . put ( JSONMapping . FORM_TYPE_ID , formTypeIdJsonObj ) ; 
JSONObject titleJsonObj = new JSONObject ( ) ; 
titleJsonObj . put ( 
Field . ElasticSearchType . TEXT ) ; 
returnVal . put ( JSONMapping . TITLE , titleJsonObj ) ; 
JSONObject formDescJsonObj = new JSONObject ( ) ; 
formDescJsonObj . put ( 
returnVal . put ( JSONMapping . FORM_DESCRIPTION , formDescJsonObj ) ; 
JSONObject stateJsonObj = new JSONObject ( ) ; 
stateJsonObj . put ( 
returnVal . put ( JSONMapping . STATE , stateJsonObj ) ; 
JSONObject flowStateJsonObj = new JSONObject ( ) ; 
flowStateJsonObj . put ( 
returnVal . put ( JSONMapping . FLOW_STATE , flowStateJsonObj ) ; 
JSONObject currentUserJsonObj = new JSONObject ( ) ; 
currentUserJsonObj . put ( 
Field . ElasticSearchType . OBJECT ) ; 
JSONObject properties = new JSONObject ( ) ; 
JSONObject currentUserUserIdJsonObj = new JSONObject ( ) ; 
currentUserUserIdJsonObj . put ( 
properties . put ( User . JSONMapping . Elastic . USER_ID , currentUserUserIdJsonObj ) ; 
JSONObject currentUserUsernameJsonObj = new JSONObject ( ) ; 
currentUserUsernameJsonObj . put ( 
properties . put ( User . JSONMapping . USERNAME , currentUserUsernameJsonObj ) ; 
ABaseFluidJSONObject . JSONMapping . Elastic . PROPERTIES , 
properties ) ; 
returnVal . put ( JSONMapping . CURRENT_USER , currentUserJsonObj ) ; 
JSONObject dateCreatedJsonObj = new JSONObject ( ) ; 
dateCreatedJsonObj . put ( 
Field . ElasticSearchType . DATE ) ; 
returnVal . put ( JSONMapping . DATE_CREATED , dateCreatedJsonObj ) ; 
JSONObject dateLastUpdatedJsonObj = new JSONObject ( ) ; 
dateLastUpdatedJsonObj . put ( 
returnVal . put ( JSONMapping . DATE_LAST_UPDATED , dateLastUpdatedJsonObj ) ; 
if ( this . getFormFields ( ) != null && 
! this . getFormFields ( ) . isEmpty ( ) ) 
JSONObject convertedField = toAdd . toJsonMappingForElasticSearch ( ) ; 
if ( convertedField == null ) 
String fieldNameAsCamel = toAdd . getFieldNameAsUpperCamel ( ) ; 
returnVal . put ( fieldNameAsCamel , convertedField ) ; 
JSONObject ancestorJsonObj = new JSONObject ( ) ; 
ancestorJsonObj . put ( 
returnVal . put ( JSONMapping . ANCESTOR_ID , ancestorJsonObj ) ; 
JSONObject tblFieldParentIdJsonObj = new JSONObject ( ) ; 
tblFieldParentIdJsonObj . put ( 
returnVal . put ( JSONMapping . TABLE_FIELD_PARENT_ID , tblFieldParentIdJsonObj ) ; 
if ( this . getFormType ( ) != null ) 
if ( this . getFormTypeId ( ) != null ) 
if ( this . getTitle ( ) != null ) 
if ( this . getFormDescription ( ) != null ) 
if ( this . getState ( ) != null ) 
returnVal . put ( JSONMapping . STATE , this . getState ( ) ) ; 
returnVal . put ( JSONMapping . FLOW_STATE , this . getFlowState ( ) ) ; 
if ( this . getCurrentUser ( ) == null ) { 
User . JSONMapping . Elastic . USER_ID , JSONObject . NULL ) ; 
currentUserJsonObj . put ( User . JSONMapping . USERNAME , JSONObject . NULL ) ; 
if ( this . getCurrentUser ( ) . getId ( ) == null || 
this . getCurrentUser ( ) . getId ( ) . longValue ( ) < 1 ) 
User . JSONMapping . Elastic . USER_ID , 
this . getCurrentUser ( ) . getId ( ) ) ; 
if ( this . getCurrentUser ( ) . getUsername ( ) == null || 
this . getCurrentUser ( ) . getUsername ( ) . trim ( ) . isEmpty ( ) ) 
currentUserJsonObj . put ( User . JSONMapping . USERNAME , 
this . getCurrentUser ( ) . getUsername ( ) ) ; 
if ( this . getFormFields ( ) != null && ! this . getFormFields ( ) . isEmpty ( ) ) 
JSONObject convertedFieldObj = toAdd . toJsonForElasticSearch ( ) ; 
if ( convertedFieldObj == null ) 
Iterator < String > iterKeys = convertedFieldObj . keys ( ) ; 
while ( iterKeys . hasNext ( ) ) 
String key = iterKeys . next ( ) ; 
returnVal . put ( key , convertedFieldObj . get ( key ) ) ; 
if ( ancestorIdLcl != null ) 
if ( this . getTableFieldParentId ( ) != null ) 
if ( this . getDescendantIds ( ) != null && ! this . getDescendantIds ( ) . isEmpty ( ) ) 
for ( Long formId : this . getDescendantIds ( ) ) 
FlatFormJSONMapping . FORM_ID , 
FlatFormJSONMapping . FORM_TITLE , 
this . getTitle ( ) == null ? 
JSONObject . NULL : this . getTitle ( ) ) ; 
FlatFormJSONMapping . FORM_TYPE , 
this . getFormType ( ) == null ? 
JSONObject . NULL : this . getFormType ( ) ) ; 
FlatFormJSONMapping . FORM_STATE , 
this . getState ( ) == null ? 
JSONObject . NULL : this . getState ( ) ) ; 
FlatFormJSONMapping . FORM_FLOW_STATE , 
this . getFlowState ( ) == null ? 
JSONObject . NULL : this . getFlowState ( ) ) ; 
FlatFormJSONMapping . FORM_DATE_CREATED , 
( this . getDateCreated ( ) == null ) ? 
JSONObject . NULL : this . getDateCreated ( ) . getTime ( ) ) ; 
FlatFormJSONMapping . FORM_DATE_LAST_UPDATED , 
( this . getDateLastUpdated ( ) == null ) ? 
JSONObject . NULL : this . getDateLastUpdated ( ) . getTime ( ) ) ; 
this . getFormFields ( ) . forEach ( 
( formFieldItem ) -> 
utilGlobal . setFlatFieldOnJSONObj ( 
FlatFormJSONMapping . FORM_FIELD_PREFIX , 
FlatFormJSONMapping . FORM_FIELD_ID_PREFIX , 
formFieldItem , 
returnVal 
if ( this . getMailTemplate ( ) != null ) 
returnVal . put ( JSONMapping . MAIL_TEMPLATE , this . getMailTemplate ( ) ) ; 
if ( this . getMailSMTPServer ( ) != null ) 
returnVal . put ( JSONMapping . MAIL_SMTP_SERVER , this . getMailSMTPServer ( ) ) ; 
if ( this . getRecipients ( ) != null && this . getRecipients ( ) . length > 0 ) 
for ( String item : this . getRecipients ( ) ) 
jsonArray . put ( item ) ; 
returnVal . put ( JSONMapping . RECIPIENTS , jsonArray ) ; 
if ( this . getAttachments ( ) != null && ! this . getAttachments ( ) . isEmpty ( ) ) 
for ( MailMessageAttachment item : this . getAttachments ( ) ) 
if ( this . getNameValues ( ) != null && 
! this . getNameValues ( ) . isEmpty ( ) ) 
for ( MailMessageNameValue item : this . getNameValues ( ) ) 
returnVal . put ( JSONMapping . NAME_VALUES , jsonArray ) ; 
returnVal . put ( JSONMapping . CLIENT , this . getPrincipalClient ( ) ) ; 
returnVal . put ( JSONMapping . SESSION_KEY , this . getSessionKeyBase64 ( ) ) ; 
returnVal . put ( JSONMapping . TICKET_EXPIRES , this . getTicketExpires ( ) ) ; 
returnVal . put ( JSONMapping . AUTHORISED_USERNAME , this . getAuthorisedUsername ( ) ) ; 
} public FluidItem sendToFlowSynchronized ( 
Form formToSendToFlowParam , 
String destinationFlowParam ) { 
if ( formToSendToFlowParam == null ) 
if ( destinationFlowParam == null || 
destinationFlowParam . trim ( ) . isEmpty ( ) ) 
FluidItem itemToSend = new FluidItem ( ) ; 
itemToSend . setFlow ( destinationFlowParam ) ; 
itemToSend . setForm ( formToSendToFlowParam ) ; 
itemToSend . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
this . sendMessage ( itemToSend , uniqueReqId ) ; 
List < FluidItem > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( 
if ( returnValue == null || returnValue . isEmpty ( ) ) 
return returnValue . get ( 0 ) ; 
catch ( InterruptedException exceptParam ) { 
catch ( ExecutionException executeProblem ) { 
if ( cause instanceof FluidClientException ) 
catch ( TimeoutException eParam ) { 
+ this . getHandler ( uniqueReqId ) . getReturnValue ( ) . size ( ) 
, FluidClientException . ErrorCode . IO_ERROR ) ; 
} public String getServiceTicketAsHexUpper ( ) { 
String serviceTicket = this . getServiceTicket ( ) ; 
if ( serviceTicket == null ) 
if ( serviceTicket . isEmpty ( ) ) 
return serviceTicket ; 
byte [ ] base64Bytes = Base64 . getDecoder ( ) . decode ( serviceTicket ) ; 
return this . bytesToHex ( base64Bytes ) ; 
} private String bytesToHex ( byte [ ] bytesToConvert ) { 
if ( bytesToConvert == null ) 
if ( bytesToConvert . length == 0 ) 
char [ ] hexChars = new char [ bytesToConvert . length * 2 ] ; 
for ( int index = 0 ; index < bytesToConvert . length ; index ++ ) { 
int andWith127 = ( bytesToConvert [ index ] & 0xFF ) ; 
hexChars [ index * 2 ] = HEX_ARRAY [ andWith127 > > > 4 ] ; 
hexChars [ index * 2 + 1 ] = HEX_ARRAY [ andWith127 & 0x0F ] ; 
return new String ( hexChars ) ; 
if ( this . getUserQuery ( ) != null ) 
returnVal . put ( JSONMapping . USER_QUERY , 
this . getUserQuery ( ) . toJsonObject ( ) ) ; 
} public Field createFieldTextMasked ( 
Field formFieldParam , String maskValueParam ) 
if ( formFieldParam != null && this . serviceTicket != null ) 
formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( maskValueParam == null || maskValueParam . trim ( ) . isEmpty ( ) ) 
maskValueParam = "" ; 
if ( formFieldParam != null ) 
formFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; 
return new Field ( this . putJson ( 
formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; 
} public Field createFieldTextBarcode ( 
Field formFieldParam , String barcodeTypeParam ) 
if ( barcodeTypeParam == null || barcodeTypeParam . trim ( ) . isEmpty ( ) ) 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; 
} public Field createFieldMultiChoicePlain ( 
Field formFieldParam , List < String > multiChoiceValuesParam ) 
if ( multiChoiceValuesParam == null ) 
multiChoiceValuesParam = new ArrayList ( ) ; 
formFieldParam . setTypeAsEnum ( Field . Type . MultipleChoice ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . PLAIN ) ; 
formFieldParam . setFieldValue ( new MultiChoice ( multiChoiceValuesParam ) ) ; 
} public Field createFieldDecimalSpinner ( 
Field formFieldParam , 
String prefixParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
formFieldParam . setTypeMetaData ( 
this . getMetaDataForDecimalAs ( 
FieldMetaData . Decimal . SPINNER , 
minParam , maxParam , stepFactorParam , prefixParam ) ) ; 
} public Field createFieldDecimalSlider ( 
double stepFactorParam ) 
FieldMetaData . Decimal . SLIDER , 
minParam , maxParam , stepFactorParam , 
null ) ) ; 
} public Field createFieldTable ( 
Form formDefinitionParam , 
boolean sumDecimalsParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . Table ) ; 
this . getMetaDataForTableField ( 
formDefinitionParam , sumDecimalsParam ) ) ; 
} public Field updateFieldTextMasked ( Field formFieldParam , String maskValueParam ) 
return new Field ( this . postJson ( 
formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; 
} public Field updateFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) 
} public Field updateFieldParagraphTextPlain ( Field formFieldParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . PLAIN ) ; 
} public Field updateFieldMultiChoicePlain ( 
List < String > multiChoiceValuesParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) { 
if ( multiChoiceValuesParam == null || 
multiChoiceValuesParam . isEmpty ( ) ) { 
List < String > beforeAvail = null , beforeSelected = null ; 
if ( formFieldParam != null ) { 
if ( formFieldParam . getFieldValue ( ) instanceof MultiChoice ) { 
MultiChoice casted = ( MultiChoice ) formFieldParam . getFieldValue ( ) ; 
beforeAvail = casted . getAvailableMultiChoices ( ) ; 
beforeSelected = casted . getSelectedMultiChoices ( ) ; 
Field returnVal = new Field ( this . postJson ( 
formFieldParam . setFieldValue ( new MultiChoice ( beforeSelected , beforeAvail ) ) ; 
} public Field updateFieldDecimalSpinner ( 
} public Field updateFieldDecimalSlider ( 
minParam , maxParam , stepFactorParam , null ) ) ; 
} public Field updateFieldTable ( 
} public Field getFieldByName ( String fieldNameParam ) 
Field field = new Field ( ) ; 
field . setFieldName ( fieldNameParam ) ; 
field . setServiceTicket ( this . serviceTicket ) ; 
field , WS . Path . FormField . Version1 . getByName ( ) ) ) ; 
} public FormFieldListing getFieldsByFormNameAndLoggedInUser ( 
String formNameParam , 
boolean editOnlyFieldsParam ) 
form . setFormType ( formNameParam ) ; 
return new FormFieldListing ( this . postJson ( 
form , WS . Path . FormField . Version1 . getByFormDefinitionAndLoggedInUser ( 
editOnlyFieldsParam ) ) ) ; 
} public FormFieldListing getFieldsByFormTypeIdAndLoggedInUser ( 
Long formTypeIdParam , 
form . setFormTypeId ( formTypeIdParam ) ; 
} public Field deleteField ( Field fieldParam ) 
if ( fieldParam != null && this . serviceTicket != null ) 
fieldParam . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( ) ) ) ; 
} public Field forceDeleteField ( Field fieldParam ) 
fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( true ) ) ) ; 
} private String getMetaDataForTableField ( 
StringBuilder returnBuffer = new StringBuilder ( ) ; 
Long definitionId = 
( formDefinitionParam == null ) ? - 1L : 
formDefinitionParam . getId ( ) ; 
returnBuffer . append ( definitionId ) ; 
returnBuffer . append ( FieldMetaData . TableField . UNDERSCORE ) ; 
returnBuffer . append ( FieldMetaData . TableField . SUM_DECIMALS ) ; 
returnBuffer . append ( sumDecimalsParam ) ; 
returnVal . put ( JSONMapping . ROLE_LISTING , this . getRoleListing ( ) ) ; 
} public Field createFieldTrueFalse ( Field formFieldParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . TrueFalse ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . TrueFalse . TRUE_FALSE ) ; 
formFieldParam , WS . Path . UserField . Version1 . userFieldCreate ( ) ) ) ; 
} public Field createFieldDateTimeDateAndTime ( Field formFieldParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; 
} public Field createFieldDecimalPlain ( Field formFieldParam ) 
formFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; 
} public Field updateFieldTrueFalse ( Field formFieldParam ) 
formFieldParam , WS . Path . UserField . Version1 . userFieldUpdate ( ) ) ) ; 
List < String > multiChoiceValuesParam ) 
} public Field updateFieldDateTimeDate ( Field formFieldParam ) 
formFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE ) ; 
} public Field updateFieldValue ( Field userFieldValueParam ) { 
if ( userFieldValueParam != null && this . serviceTicket != null ) { 
userFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
userFieldValueParam , 
WS . Path . UserField . Version1 . userFieldUpdateValue ( ) ) ) ; 
} public Field getFieldByName ( String fieldNameParam ) { 
field . setFieldValue ( new MultiChoice ( ) ) ; 
field , WS . Path . UserField . Version1 . getByName ( ) ) ) ; 
} public Field deleteField ( Field fieldParam ) { 
if ( fieldParam != null && this . serviceTicket != null ) { 
return new Field ( this . postJson ( fieldParam , WS . Path . UserField . Version1 . userFieldDelete ( ) ) ) ; 
fieldParam , WS . Path . UserField . Version1 . userFieldDelete ( true ) ) ) ; 
} public void mergeMappingForIndex ( 
String parentTypeParam , 
Form fluidFormMappingToUpdateParam 
if ( indexParam == null ) { 
if ( fluidFormMappingToUpdateParam == null ) { 
if ( fluidFormMappingToUpdateParam . getFormTypeId ( ) == null || 
fluidFormMappingToUpdateParam . getFormTypeId ( ) . longValue ( ) < 1 ) { 
String formTypeString = 
fluidFormMappingToUpdateParam . getFormTypeId ( ) . toString ( ) ; 
JSONObject newContentMappingBuilderFromParam = 
fluidFormMappingToUpdateParam . toJsonMappingForElasticSearch ( ) ; 
GetIndexResponse getExistingIndex = this . getOrCreateIndex ( indexParam ) ; 
JSONObject existingPropsToUpdate = null ; 
for ( ObjectCursor mappingKey : getExistingIndex . getMappings ( ) . keys ( ) ) { 
if ( ! mappingKey . value . toString ( ) . equals ( indexParam ) ) { 
Object obj = getExistingIndex . getMappings ( ) . get ( mappingKey . value . toString ( ) ) ; 
if ( obj instanceof ImmutableOpenMap ) { 
ImmutableOpenMap casted = ( ImmutableOpenMap ) obj ; 
if ( casted . containsKey ( formTypeString ) && 
casted . get ( formTypeString ) instanceof MappingMetaData ) { 
MappingMetaData mappingMetaData = ( MappingMetaData ) casted . get ( formTypeString ) ; 
existingPropsToUpdate = new JSONObject ( mappingMetaData . source ( ) . string ( ) ) ; 
eParam . getMessage ( ) , eParam ) ; 
if ( existingPropsToUpdate == null ) { 
existingPropsToUpdate = new JSONObject ( ) ; 
existingPropsToUpdate . put ( 
newContentMappingBuilderFromParam ) ; 
this . setAdditionalProps ( 
existingPropsToUpdate , parentTypeParam ) ; 
PutMappingRequestBuilder putMappingRequestBuilder = 
this . client . admin ( ) . indices ( ) . preparePutMapping ( indexParam ) ; 
putMappingRequestBuilder = putMappingRequestBuilder . setType ( formTypeString ) ; 
putMappingRequestBuilder = putMappingRequestBuilder . setSource ( 
existingPropsToUpdate . toString ( ) , XContentType . JSON ) ; 
PutMappingResponse putMappingResponse = putMappingRequestBuilder . get ( ) ; 
if ( ! putMappingResponse . isAcknowledged ( ) ) { 
JSONObject existingPropertiesUpdated = 
existingPropsToUpdate . getJSONObject ( formTypeString ) . getJSONObject ( 
ABaseFluidJSONObject . JSONMapping . Elastic . PROPERTIES ) ; 
for ( String existingKey : existingPropertiesUpdated . keySet ( ) ) { 
newContentMappingBuilderFromParam . put ( existingKey , 
existingPropertiesUpdated . get ( existingKey ) ) ; 
boolean noChanges = true ; 
for ( String possibleExistingKey : newContentMappingBuilderFromParam . keySet ( ) ) { 
if ( ! existingPropertiesUpdated . has ( possibleExistingKey ) ) { 
noChanges = false ; 
if ( noChanges ) { 
existingPropsToUpdate , 
parentTypeParam ) ; 
} private void setAdditionalProps ( 
JSONObject existingPropsToUpdateParam , 
String parentTypeParam 
if ( parentTypeParam == null || parentTypeParam . trim ( ) . length ( ) == 0 ) { 
JSONObject typeJson = new JSONObject ( ) ; 
typeJson . put ( Field . JSONMapping . FIELD_TYPE , parentTypeParam ) ; 
existingPropsToUpdateParam . put ( 
Form . JSONMapping . _PARENT , typeJson ) ; 
} public GetIndexResponse getOrCreateIndex ( String indexParam ) { 
if ( this . doesIndexExist ( indexParam ) ) { 
return this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; 
CreateIndexRequestBuilder createIndexRequestBuilder = 
this . client . admin ( ) . indices ( ) . prepareCreate ( indexParam ) ; 
CreateIndexResponse mappingCreateResponse = 
createIndexRequestBuilder . execute ( ) . actionGet ( ) ; 
if ( ! mappingCreateResponse . isAcknowledged ( ) ) { 
if ( this . getViewName ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_NAME , this . getViewName ( ) ) ; 
if ( this . getViewGroupName ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_GROUP_NAME , this . getViewGroupName ( ) ) ; 
returnVal . put ( JSONMapping . VIEW_FLOW_NAME , this . getViewFlowName ( ) ) ; 
returnVal . put ( JSONMapping . VIEW_STEP_NAME , this . getViewStepName ( ) ) ; 
if ( this . getViewPriority ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_PRIORITY , this . getViewPriority ( ) ) ; 
if ( this . getViewType ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_TYPE , this . getViewType ( ) ) ; 
if ( this . getDatasourceName ( ) != null ) { 
returnVal . put ( JSONMapping . DATASOURCE_NAME , 
this . getDatasourceName ( ) ) ; 
if ( this . getQuery ( ) != null ) { 
returnVal . put ( JSONMapping . QUERY , this . getQuery ( ) ) ; 
if ( this . getStoredProcedure ( ) != null ) { 
JSONMapping . STORED_PROCEDURE , 
this . getStoredProcedure ( ) ) ; 
if ( this . getSqlInputs ( ) != null ) 
for ( SQLColumn toAdd : this . getSqlInputs ( ) ) 
returnVal . put ( JSONMapping . SQL_INPUTS , jsonArray ) ; 
public void addSqlInput ( SQLColumn sqlInputToAddParam ) { 
if ( this . sqlInputs == null ) { 
this . sqlInputs = new ArrayList < > ( ) ; 
if ( sqlInputToAddParam == null ) { 
this . sqlInputs . add ( sqlInputToAddParam ) ; 
} public Flow createFlow ( Flow flowParam ) 
if ( flowParam != null && this . serviceTicket != null ) 
return new Flow ( this . putJson ( 
flowParam , WS . Path . Flow . Version1 . flowCreate ( ) ) ) ; 
} public Flow updateFlow ( Flow flowParam ) 
return new Flow ( this . postJson ( 
flowParam , WS . Path . Flow . Version1 . flowUpdate ( ) ) ) ; 
} public Flow getFlowById ( Long flowIdParam ) 
Flow flow = new Flow ( flowIdParam ) ; 
flow . setServiceTicket ( this . serviceTicket ) ; 
flow , WS . Path . Flow . Version1 . getById ( ) ) ) ; 
} public Flow getFlowByName ( String flowNameParam ) 
Flow flow = new Flow ( ) ; 
flow . setName ( flowNameParam ) ; 
flow , WS . Path . Flow . Version1 . getByName ( ) ) ) ; 
} public Flow deleteFlow ( Flow flowParam ) 
return new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( ) ) ) ; 
} public Flow forceDeleteFlow ( Flow flowParam ) 
return new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( true ) ) ) ; 
} public Field updateFieldValue ( Field globalFieldValueParam ) 
if ( globalFieldValueParam != null && this . serviceTicket != null ) 
globalFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
globalFieldValueParam , 
Version1 . globalFieldUpdateValue ( ) ) ) ; 
} public Field getFieldValueByName ( String fieldNameParam ) 
return this . getFieldValueBy ( field ) ; 
} private Field getFieldValueBy ( Field fieldParam ) 
if ( fieldParam != null ) 
fieldParam . setFieldValue ( new MultiChoice ( ) ) ; 
fieldParam , Version1 . getValueBy ( ) ) ) ; 
} public List < Field > getAllGlobalFieldValues ( ) 
return new GlobalFieldListing ( this . postJson ( 
field , Version1 . getAllValues ( ) ) ) . getListing ( ) ; 
boolean includeTableFieldsParam ) 
StringBuffer ancestorQuery = new StringBuffer ( 
Form . JSONMapping . DESCENDANT_IDS ) ; 
ancestorQuery . append ( ":\"" ) ; 
ancestorQuery . append ( electronicFormIdParam ) ; 
ancestorQuery . append ( "\"" ) ; 
List < Form > ancestorForms = null ; 
ancestorForms = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( ancestorQuery . toString ( ) ) , 
Index . DOCUMENT , 
DEFAULT_OFFSET , 
ancestorForms = this . searchAndConvertHitsToFormWithNoFields ( 
if ( ancestorForms != null && ! ancestorForms . isEmpty ( ) ) 
returnVal = ancestorForms . get ( 0 ) ; 
if ( ! includeTableFieldsParam ) 
this . populateTableFields ( 
returnVal . getFormFields ( ) ) ; 
List < Long > electronicFormIds = new ArrayList ( ) ; 
electronicFormIds . add ( electronicFormIdParam ) ; 
return this . getFormDescendants ( 
electronicFormIds , 
} public List < Form > getFormDescendants ( 
boolean includeTableFieldFormRecordInfoParam ) 
if ( electronicFormIdsParam == null || 
electronicFormIdsParam . isEmpty ( ) ) 
StringBuffer descendantQuery = new StringBuffer ( Form . JSONMapping . ANCESTOR_ID ) ; 
descendantQuery . append ( ":(" ) ; 
for ( Long electronicFormId : electronicFormIdsParam ) 
descendantQuery . append ( "\"" ) ; 
descendantQuery . append ( electronicFormId ) ; 
String fullQueryToExec = descendantQuery . toString ( ) ; 
fullQueryToExec = fullQueryToExec . substring ( 
0 , fullQueryToExec . length ( ) - 1 ) ; 
fullQueryToExec = fullQueryToExec . concat ( ")" ) ; 
QueryBuilders . queryStringQuery ( fullQueryToExec ) , 
DEFAULT_OFFSET , MAX_NUMBER_OF_TABLE_RECORDS , 
for ( Form descendantForm : returnVal ) 
descendantForm . getFormFields ( ) ) ; 
boolean includeFieldDataParam ) 
StringBuffer primaryQuery = new StringBuffer ( 
ABaseFluidJSONObject . JSONMapping . ID ) ; 
primaryQuery . append ( ":\"" ) ; 
primaryQuery . append ( electronicFormIdParam ) ; 
primaryQuery . append ( "\"" ) ; 
List < Form > formsWithId = null ; 
formsWithId = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( primaryQuery . toString ( ) ) , 
formsWithId = this . searchAndConvertHitsToFormWithNoFields ( 
if ( formsWithId != null && ! formsWithId . isEmpty ( ) ) 
returnVal = formsWithId . get ( 0 ) ; 
if ( returnVal == null ) { 
return this . populateTableFields ( 
} public Map < Long , String > getFormDefinitionIdAndTitle ( ) 
if ( ! LOCAL_MAPPING . isEmpty ( ) ) 
Map < Long , String > returnVal = new HashMap < > ( LOCAL_MAPPING ) ; 
if ( System . currentTimeMillis ( ) > timeToUpdateAgain ) { 
synchronized ( LOCAL_MAPPING ) 
LOCAL_MAPPING . clear ( ) ; 
return new HashMap < > ( LOCAL_MAPPING ) ; 
ISyntax . ProcedureMapping . FormDefinition . GetFormDefinitions ) ; 
Long id = resultSet . getLong ( 1 ) ; 
String title = resultSet . getString ( 2 ) ; 
LOCAL_MAPPING . put ( id , title ) ; 
timeToUpdateAgain = 
( System . currentTimeMillis ( ) + 
TimeUnit . MINUTES . toMillis ( 10 ) ) ; 
if ( this . getServiceTicketBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . SERVICE_TICKET_BASE_64 , this . getServiceTicketBase64 ( ) ) ; 
if ( this . getDataBase64 ( ) != null ) 
returnVal . put ( JSONMapping . DATA_BASE_64 , 
this . getDataBase64 ( ) ) ; 
if ( this . getSumDecimals ( ) != null ) 
returnVal . put ( JSONMapping . SUM_DECIMALS , this . getSumDecimals ( ) ) ; 
if ( this . getTableRecords ( ) != null && ! this . getTableRecords ( ) . isEmpty ( ) ) 
JSONArray assoFormsArr = new JSONArray ( ) ; 
for ( Form toAdd : this . getTableRecords ( ) ) 
assoFormsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . TABLE_RECORDS , assoFormsArr ) ; 
int listingCountFromListing = 0 ; 
if ( this . getListing ( ) != null && ! this . getListing ( ) . isEmpty ( ) ) 
listingCountFromListing = this . getListing ( ) . size ( ) ; 
for ( T toAdd : this . getListing ( ) ) 
returnVal . put ( JSONMapping . LISTING , jsonArray ) ; 
if ( this . getListingCount ( ) == null ) 
returnVal . put ( JSONMapping . LISTING_COUNT , new Integer ( listingCountFromListing ) ) ; 
returnVal . put ( JSONMapping . LISTING_COUNT , this . getListingCount ( ) ) ; 
if ( this . getListingIndex ( ) != null ) 
returnVal . put ( JSONMapping . LISTING_INDEX , this . getListingIndex ( ) ) ; 
returnVal . put ( JSONMapping . LISTING_PAGE , this . getListingPage ( ) ) ; 
} public boolean isExpired ( ) 
if ( this . getExpirationTime ( ) == null ) 
Date expirationTime = new Date ( this . getExpirationTime ( ) ) ; 
return ( expirationTime . before ( new Date ( ) ) ) ; 
} public UserNotification createUserNotification ( UserNotification userNotificationParam ) 
if ( userNotificationParam != null && this . serviceTicket != null ) 
userNotificationParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserNotification ( this . putJson ( 
userNotificationParam , 
WS . Path . UserNotification . Version1 . userNotificationCreate ( ) ) ) ; 
} public UserNotification updateUserNotification ( 
UserNotification userNotificationParam ) 
return new UserNotification ( this . postJson ( 
WS . Path . UserNotification . Version1 . userNotificationUpdate ( ) ) ) ; 
} public UserNotification markUserNotificationAsRead ( 
UserNotification userNotificationParam , 
boolean asyncParam ) 
WS . Path . UserNotification . Version1 . userNotificationMarkAsRead ( asyncParam ) ) ) ; 
} public UserNotification deleteUserNotification ( 
UserNotification userNotificationToDeleteParam ) 
if ( userNotificationToDeleteParam != null && this . serviceTicket != null ) 
userNotificationToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserNotification ( this . postJson ( userNotificationToDeleteParam , 
WS . Path . UserNotification . Version1 . userNotificationDelete ( ) ) ) ; 
} public UserNotification getUserNotificationById ( 
Long userNotificationPkParam ) 
UserNotification userNoti = new UserNotification ( ) ; 
userNoti . setId ( userNotificationPkParam ) ; 
userNoti . setServiceTicket ( this . serviceTicket ) ; 
userNoti , WS . Path . UserNotification . Version1 . getById ( ) ) ) ; 
} public List < UserNotification > getAllReadByLoggedInUser ( 
return new UserNotificationListing ( this . postJson ( 
WS . Path . UserNotification . Version1 . getAllReadByUser ( 
offsetParam ) ) ) . getListing ( ) ; 
} public List < UserNotification > getAllByUserAndDateBetween ( 
User userParam , 
Date fromDateParam , 
Date toDateParam 
return this . getAllByUserAndDateBetween ( 
- 1 , 
fromDateParam , 
toDateParam 
if ( this . serviceTicket != null && userParam != null ) { 
long fromDate = 
( fromDateParam == null ) ? 
System . currentTimeMillis ( ) - TimeUnit . DAYS . toMillis ( 7 ) 
: fromDateParam . getTime ( ) ; 
long toDate = 
( toDateParam == null ) ? 
System . currentTimeMillis ( ) : toDateParam . getTime ( ) ; 
WS . Path . UserNotification . Version1 . getAllByUserAndDate ( 
fromDate , 
toDate 
) ) ) . getListing ( ) ; 
} public static byte [ ] generateRandom ( int seedParam ) { 
if ( AES256Local . secureRandom == null ) 
AES256Local . secureRandom = new SecureRandom ( ) ; 
return new IvParameterSpec ( AES256Local . secureRandom . generateSeed ( seedParam ) ) . getIV ( ) ; 
} public static byte [ ] hmacSha256 ( byte [ ] hMacKeyParam , byte [ ] encryptedDataParam ) { 
Mac hmac = Mac . getInstance ( HMAC_ALGO ) ; 
hmac . init ( new SecretKeySpec ( hMacKeyParam , HMAC_ALGO ) ) ; 
return hmac . doFinal ( encryptedDataParam ) ; 
catch ( NoSuchAlgorithmException except ) { 
FluidClientException . ErrorCode . AES_256 ) ; 
catch ( InvalidKeyException except ) { 
} public static byte [ ] generateLocalHMAC ( 
byte [ ] encryptedDataParam , String passwordParam , String saltParam , byte [ ] seedParam ) { 
byte [ ] poisonedSeed = poisonBytes ( seedParam ) ; 
byte [ ] passwordSha256 = sha256 ( 
passwordParam . concat ( saltParam ) . getBytes ( ) ) ; 
byte [ ] derivedKey = sha256 ( UtilGlobal . addAll ( passwordSha256 , poisonedSeed ) ) ; 
return hmacSha256 ( derivedKey , encryptedDataParam ) ; 
} public static byte [ ] generateLocalHMACForReqToken ( 
byte [ ] encryptedDataParam , byte [ ] keyParam , byte [ ] seedParam ) { 
byte [ ] derivedKey = sha256 ( UtilGlobal . addAll ( keyParam , poisonedSeed ) ) ; 
} private static byte [ ] poisonBytes ( byte [ ] bytesToPoisonParam ) { 
if ( bytesToPoisonParam == null ) { 
byte [ ] returnVal = new byte [ bytesToPoisonParam . length ] ; 
for ( int index = 0 ; index < bytesToPoisonParam . length ; index ++ ) { 
byte poisoned = ( byte ) ( bytesToPoisonParam [ index ] ^ 222 ) ; 
returnVal [ index ] = poisoned ; 
} public static byte [ ] decryptInitPacket ( 
byte [ ] encryptedDataParam , 
String saltParam , 
byte [ ] ivParam , 
byte [ ] seedParam ) { 
byte [ ] passwordSha256 = sha256 ( passwordParam . concat ( saltParam ) . getBytes ( ) ) ; 
byte [ ] derivedKey = sha256 ( UtilGlobal . addAll ( passwordSha256 , seedParam ) ) ; 
return decrypt ( derivedKey , encryptedDataParam , ivParam ) ; 
} public static byte [ ] decrypt ( byte [ ] keyParam , byte [ ] dataToDecryptParam , byte [ ] ivParam ) { 
Key key = new SecretKeySpec ( keyParam , KEY_ALGO ) ; 
Cipher cipher = Cipher . getInstance ( ALGO_CBC ) ; 
cipher . init ( Cipher . DECRYPT_MODE , key , new IvParameterSpec ( ivParam ) ) ; 
return cipher . doFinal ( dataToDecryptParam ) ; 
except . getMessage ( ) , except , FluidClientException . ErrorCode . AES_256 ) ; 
} catch ( InvalidAlgorithmParameterException except ) { 
} catch ( IllegalBlockSizeException except ) { 
} catch ( NoSuchPaddingException except ) { 
} catch ( NoSuchAlgorithmException except ) { 
} catch ( BadPaddingException except ) { 
} public static byte [ ] encrypt ( byte [ ] keyParam , byte [ ] dataToEncryptParam , byte [ ] ivParam ) { 
if ( dataToEncryptParam == null ) { 
cipher . init ( Cipher . ENCRYPT_MODE , key , new IvParameterSpec ( ivParam ) ) ; 
return cipher . doFinal ( dataToEncryptParam ) ; 
} public static byte [ ] sha256 ( final byte [ ] dataParam ) { 
if ( dataParam == null || dataParam . length == 0 ) { 
final MessageDigest digest = MessageDigest . getInstance ( "SHA-256" ) ; 
return digest . digest ( dataParam ) ; 
catch ( final NoSuchAlgorithmException e ) { 
} public void sendMessage ( 
ABaseFluidJSONObject baseFluidJSONObjectParam , 
String requestIdParam ) 
if ( baseFluidJSONObjectParam != null ) { 
baseFluidJSONObjectParam . setServiceTicket ( this . serviceTicket ) ; 
if ( this . getHandler ( requestIdParam ) instanceof AGenericListMessageHandler ) { 
AGenericListMessageHandler listHandler = 
( AGenericListMessageHandler ) this . getHandler ( requestIdParam ) ; 
listHandler . addExpectedMessage ( baseFluidJSONObjectParam . getEcho ( ) ) ; 
this . webSocketClient . sendMessage ( baseFluidJSONObjectParam ) ; 
public void closeAndClean ( ) 
} public synchronized String initNewRequest ( ) { 
String returnVal = UUID . randomUUID ( ) . toString ( ) ; 
this . messageHandler . put ( returnVal , this . getNewHandlerInstance ( ) ) ; 
} private String getWebSocketBaseURIFrom ( String webServiceURLParam ) 
if ( webServiceURLParam == null ) 
if ( webServiceURLParam . trim ( ) . length ( ) == 0 ) 
URI uri = URI . create ( webServiceURLParam ) ; 
String scheme = uri . getScheme ( ) ; 
if ( scheme == null ) 
scheme = scheme . trim ( ) . toLowerCase ( ) ; 
if ( Constant . HTTP . equals ( scheme ) ) { 
returnBuffer . append ( Constant . WS ) ; 
else if ( Constant . HTTPS . equals ( scheme ) ) { 
returnBuffer . append ( Constant . WSS ) ; 
returnBuffer . append ( uri . getScheme ( ) ) ; 
returnBuffer . append ( Constant . SCHEME_SEP ) ; 
returnBuffer . append ( uri . getHost ( ) ) ; 
if ( uri . getPort ( ) > 0 ) 
returnBuffer . append ( Constant . COLON ) ; 
returnBuffer . append ( uri . getPort ( ) ) ; 
returnBuffer . append ( uri . getPath ( ) ) ; 
} protected void setEchoIfNotSet ( ABaseFluidVO baseToSetEchoOnIfNotSetParam ) { 
if ( baseToSetEchoOnIfNotSetParam == null ) { 
} else if ( baseToSetEchoOnIfNotSetParam . getEcho ( ) == null || 
baseToSetEchoOnIfNotSetParam . getEcho ( ) . trim ( ) . isEmpty ( ) ) { 
baseToSetEchoOnIfNotSetParam . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
} protected String getExceptionMessageVerbose ( 
String prefixParam , 
String uniqueReqIdParam , 
int numberOfSentItemsParam 
StringBuilder formFieldsCombined = new StringBuilder ( ) ; 
int returnValSize = - 1 ; 
RespHandler respHandler = this . getHandler ( uniqueReqIdParam ) ; 
if ( respHandler instanceof AGenericListMessageHandler ) { 
List < ? extends ABaseFluidJSONObject > returnValue = 
( ( AGenericListMessageHandler ) respHandler ) . getReturnValue ( ) ; 
if ( returnValue != null ) { 
returnValSize = returnValue . size ( ) ; 
returnValue . forEach ( listingItm -> { 
if ( listingItm instanceof ABaseListing ) { 
ABaseListing castedToListing = ( ABaseListing ) listingItm ; 
if ( castedToListing != null ) { 
castedToListing . getListing ( ) . forEach ( formItm -> { 
formFieldsCombined . append ( formItm . toString ( ) ) ; 
formFieldsCombined . append ( listingItm . toString ( ) ) ; 
formFieldsCombined . toString ( ) + "'." ) ; 
} public User createAdminUser ( String passwordParam ) { 
User adminUserCreate = new User ( ) ; 
adminUserCreate . setPasswordClear ( passwordParam ) ; 
adminUserCreate , WS . Path . User . Version1 . userCreateAdmin ( ) ) ) ; 
if ( this . getUser ( ) != null ) 
if ( this . getDateRead ( ) != null ) 
returnVal . put ( JSONMapping . DATE_READ , 
this . getDateAsLongFromJson ( this . getDateRead ( ) ) ) ; 
if ( this . getExpiringLink ( ) != null ) 
returnVal . put ( JSONMapping . EXPIRING_LINK , this . getExpiringLink ( ) ) ; 
if ( this . getMessage ( ) != null ) 
returnVal . put ( JSONMapping . MESSAGE , this . getMessage ( ) ) ; 
returnVal . put ( JSONMapping . USER_NOTIFICATION_TYPE , this . getUserNotificationType ( ) ) ; 
if ( this . getFormContainer ( ) != null ) { 
if ( this . getMessage ( ) != null ) { 
if ( this . getDateRead ( ) != null ) { 
if ( this . getDateSent ( ) != null ) { 
returnVal . put ( JSONMapping . DATE_SENT , 
this . getDateAsLongFromJson ( this . getDateSent ( ) ) ) ; 
if ( this . getFromUser ( ) != null ) { 
JSONMapping . FROM_USER , 
this . getFromUser ( ) . toJsonObject ( ) ) ; 
if ( this . getToUser ( ) != null ) { 
JSONMapping . TO_USER , 
this . getToUser ( ) . toJsonObject ( ) ) ; 
} public AccessToken getAccessToken ( 
String clientIdParam , 
String clientSecretParam , 
String codeParam , 
String redirectUrlParam ) 
if ( clientIdParam == null || clientIdParam . trim ( ) . isEmpty ( ) ) 
if ( clientSecretParam == null || clientSecretParam . trim ( ) . isEmpty ( ) ) 
if ( codeParam == null || codeParam . trim ( ) . isEmpty ( ) ) 
AccessTokenRequest tokenRequest = new AccessTokenRequest ( ) ; 
tokenRequest . setClientId ( clientIdParam ) ; 
tokenRequest . setClientSecret ( clientSecretParam ) ; 
tokenRequest . setGrantType ( AUTHORIZATION_CODE ) ; 
tokenRequest . setCode ( codeParam ) ; 
tokenRequest . setRedirectUri ( redirectUrlParam ) ; 
return new AccessToken ( this . postJson ( 
tokenRequest , WS . Path . Auth0 . Version1 . userToken ( ) ) ) ; 
} public NormalizedUserProfile getUserProfileInfo ( AccessToken accessTokenParam ) 
if ( accessTokenParam == null || ( accessTokenParam . getAccessToken ( ) == null || 
accessTokenParam . getAccessToken ( ) . trim ( ) . isEmpty ( ) ) ) 
String accessToken = accessTokenParam . getAccessToken ( ) ; 
List < HeaderNameValue > headerListing = new ArrayList < HeaderNameValue > ( ) ; 
headerListing . add ( new HeaderNameValue ( 
NormalizedUserProfile . HeaderMapping . AUTHORIZATION , 
return new NormalizedUserProfile ( 
this . getJson ( true , WS . Path . Auth0 . Version1 . userInfo ( ) , headerListing ) ) ; 
} public Form getFormFields ( Long electronicFormIdParam , boolean includeTableFieldsParam ) { 
StringBuffer primaryQuery = new StringBuffer ( ABaseFluidJSONObject . JSONMapping . ID ) ; 
List < Form > formsWithId = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( primaryQuery . toString ( ) ) , Index . DOCUMENT , 
DEFAULT_OFFSET , 1 , 
if ( formsWithId != null && ! formsWithId . isEmpty ( ) ) { 
if ( ! includeTableFieldsParam ) { 
this . populateTableFields ( false , true , returnVal . getFormFields ( ) ) ; 
if ( this . getFilename ( ) != null ) 
returnVal . put ( JSONMapping . FILENAME , this . getFilename ( ) ) ; 
if ( this . getSha256sum ( ) != null ) 
returnVal . put ( JSONMapping . SHA_256_SUM , this . getSha256sum ( ) ) ; 
if ( this . isAddToolsToClassPath ( ) != null ) 
returnVal . put ( JSONMapping . ADD_TOOLS_TO_CLASS_PATH , this . isAddToolsToClassPath ( ) ) ; 
if ( this . getLibraryDataBase64 ( ) != null ) 
returnVal . put ( JSONMapping . LIBRARY_DATA_BASE64 , 
this . getLibraryDataBase64 ( ) ) ; 
} private String executeHttp ( 
HttpClient httpClientParam , 
HttpUriRequest httpUriRequestParam , 
ResponseHandler responseHandlerParam , 
String postfixUrlParam 
Object returnedObj = httpClientParam . execute ( httpUriRequestParam , responseHandlerParam ) ; 
if ( returnedObj instanceof String ) { 
return ( String ) returnedObj ; 
} else if ( returnedObj == null ) { 
( returnedObj == null ) ? null : returnedObj . getClass ( ) . getName ( ) ) + "'." , 
} catch ( IOException except ) { 
if ( except instanceof UnknownHostException ) { 
except , FluidClientException . ErrorCode . CONNECT_ERROR ) ; 
if ( except instanceof ConnectException ) { 
throw new FluidClientException ( except . getMessage ( ) , 
except , 
FluidClientException . ErrorCode . CONNECT_ERROR ) ; 
except . getMessage ( ) , 
} public JSONObject getJson ( 
String postfixUrlParam , 
List < HeaderNameValue > headerNameValuesParam ) { 
return this . getJson ( 
postfixUrlParam , 
headerNameValuesParam ) ; 
boolean checkConnectionValidParam , 
if ( checkConnectionValidParam && ! this . isConnectionValid ( ) ) { 
this . endpointUrl . concat ( postfixUrlParam ) + "'." , 
CloseableHttpClient httpclient = this . getClient ( ) ; 
HttpGet httpGet = new HttpGet ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
if ( headerNameValuesParam != null && ! headerNameValuesParam . isEmpty ( ) ) { 
for ( HeaderNameValue headerNameVal : headerNameValuesParam ) { 
if ( headerNameVal . getName ( ) == null || headerNameVal . getName ( ) . trim ( ) . isEmpty ( ) ) { 
if ( headerNameVal . getValue ( ) == null ) { 
httpGet . setHeader ( headerNameVal . getName ( ) , headerNameVal . getValue ( ) ) ; 
ResponseHandler < String > responseHandler = this . getJsonResponseHandler ( 
this . endpointUrl . concat ( postfixUrlParam ) ) ; 
String responseBody = this . executeHttp ( 
httpclient , httpGet , responseHandler , postfixUrlParam ) ; 
if ( responseBody == null || responseBody . trim ( ) . isEmpty ( ) ) { 
JSONObject jsonOjb = new JSONObject ( responseBody ) ; 
if ( jsonOjb . isNull ( Error . JSONMapping . ERROR_CODE ) ) { 
return jsonOjb ; 
int errorCode = jsonOjb . getInt ( Error . JSONMapping . ERROR_CODE ) ; 
if ( errorCode > 0 ) { 
String errorMessage = ( jsonOjb . isNull ( Error . JSONMapping . ERROR_MESSAGE ) 
jsonOjb . getString ( Error . JSONMapping . ERROR_MESSAGE ) ) ; 
throw new FluidClientException ( errorMessage , errorCode ) ; 
} protected JSONObject postJson ( 
ABaseFluidJSONObject baseDomainParam , 
String postfixUrlParam ) { 
return this . postJson ( false , baseDomainParam , postfixUrlParam ) ; 
List < HeaderNameValue > headerNameValuesParam , 
return this . executeJson ( 
HttpMethod . POST , 
headerNameValuesParam , 
checkConnectionValidParam , 
baseDomainParam , 
ContentType . APPLICATION_JSON , 
postfixUrlParam ) ; 
} protected JSONObject deleteJson ( 
return this . deleteJson ( false , baseDomainParam , postfixUrlParam ) ; 
HttpMethod . DELETE , 
} protected JSONObject postForm ( 
List < FormNameValue > formNameValuesParam , 
return this . executeForm ( 
formNameValuesParam , 
ContentType . APPLICATION_FORM_URLENCODED , 
} protected JSONObject putJson ( 
HttpMethod . PUT , 
return this . putJson ( false , baseDomainParam , postfixUrlParam ) ; 
} protected JSONObject executeJson ( 
HttpMethod httpMethodParam , 
ContentType contentTypeParam , 
if ( baseDomainParam == null ) { 
String bodyJsonString = baseDomainParam . toJsonObject ( ) . toString ( ) ; 
return this . executeString ( 
httpMethodParam , 
bodyJsonString , 
contentTypeParam , 
} protected JSONObject executeForm ( 
if ( formNameValuesParam == null || formNameValuesParam . isEmpty ( ) ) { 
StringBuilder strBuilder = new StringBuilder ( ) ; 
for ( FormNameValue nameValue : formNameValuesParam ) { 
if ( nameValue . getName ( ) == null || nameValue . getName ( ) . trim ( ) . isEmpty ( ) ) { 
if ( nameValue . getValue ( ) == null ) { 
strBuilder . append ( nameValue . getName ( ) ) ; 
strBuilder . append ( EQUALS ) ; 
strBuilder . append ( nameValue . getValue ( ) ) ; 
strBuilder . append ( AMP ) ; 
String bodyJsonString = strBuilder . toString ( ) ; 
bodyJsonString = bodyJsonString . substring ( 0 , bodyJsonString . length ( ) - 1 ) ; 
bodyJsonString , contentTypeParam , postfixUrlParam ) ; 
} protected JSONObject executeString ( 
String stringParam , 
String responseBody = this . executeTxtReceiveTxt ( 
stringParam , 
if ( jsonOjb . isNull ( Error . JSONMapping . ERROR_CODE ) ) 
if ( errorCode > 0 ) 
if ( responseBody != null && ! responseBody . trim ( ) . isEmpty ( ) ) { 
responseBody , 
} protected String executeTxtReceiveTxt ( 
if ( stringParam == null || stringParam . isEmpty ( ) ) { 
String responseBody = null ; 
HttpUriRequest uriRequest = null ; 
if ( httpMethodParam == HttpMethod . POST ) { 
if ( contentTypeParam == ContentType . APPLICATION_FORM_URLENCODED ) { 
RequestBuilder builder = RequestBuilder . post ( ) . setUri ( 
builder = this . addParamsToBuildFromString ( builder , stringParam ) ; 
uriRequest = builder . build ( ) ; 
uriRequest = new HttpPost ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
uriRequest . setHeader ( CONTENT_TYPE_HEADER , contentTypeParam . toString ( ) ) ; 
} else if ( httpMethodParam == HttpMethod . PUT ) { 
RequestBuilder builder = RequestBuilder . put ( ) . setUri ( 
uriRequest = new HttpPut ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
} else if ( httpMethodParam == HttpMethod . DELETE ) { 
uriRequest = new HttpDelete ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
if ( uriRequest == null ) { 
uriRequest . setHeader ( headerNameVal . getName ( ) , headerNameVal . getValue ( ) ) ; 
if ( uriRequest instanceof HttpEntityEnclosingRequestBase ) { 
HttpEntity httpEntity = new StringEntity ( stringParam , contentTypeParam ) ; 
( ( HttpEntityEnclosingRequestBase ) uriRequest ) . setEntity ( httpEntity ) ; 
responseBody = this . executeHttp ( httpclient , uriRequest , 
responseHandler , postfixUrlParam ) ; 
} catch ( FluidClientException fluidClientExcept ) { 
throw fluidClientExcept ; 
} catch ( Exception otherExcept ) { 
throw new FluidClientException ( otherExcept . getMessage ( ) , 
otherExcept , FluidClientException . ErrorCode . ILLEGAL_STATE_ERROR ) ; 
} private RequestBuilder addParamsToBuildFromString ( 
RequestBuilder builderParam , 
String formDataToAddParam 
String [ ] nameValuePairs = formDataToAddParam . split ( REGEX_AMP ) ; 
if ( nameValuePairs . length > 0 ) { 
for ( String nameValuePair : nameValuePairs ) { 
String [ ] nameValuePairArr = nameValuePair . split ( REGEX_EQUALS ) ; 
if ( nameValuePairArr . length > 1 ) { 
String name = nameValuePairArr [ 0 ] ; 
String value = nameValuePairArr [ 1 ] ; 
builderParam = builderParam . addParameter ( name , value ) ; 
return builderParam ; 
} private ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { 
ResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { 
public String handleResponse ( final HttpResponse responseParam ) throws IOException { 
int status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; 
if ( status == 404 ) { 
urlCalledParam + "]." , 
} else if ( status >= 200 && status < 300 ) { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseJsonString = ( entity == null ) ? null : 
EntityUtils . toString ( entity ) ; 
return responseJsonString ; 
} else if ( status == 400 ) { 
String responseString = ( entity != null ) ? 
EntityUtils . toString ( entity ) : null ; 
responseString + "]" , 
return responseHandler ; 
} public static String encodeParam ( String textParam ) { 
if ( textParam == null ) { 
return URLEncoder . encode ( textParam , ENCODING_UTF_8 ) ; 
} public boolean isConnectionValid ( ) { 
WS . Path . Test . Version1 . testConnection ( ) ) ; 
} catch ( FluidClientException flowJobExcept ) { 
if ( flowJobExcept . getErrorCode ( ) == FluidClientException . ErrorCode . CONNECT_ERROR ) { 
throw flowJobExcept ; 
} protected boolean isError ( ABaseFluidJSONObject baseDomainParam ) { 
if ( baseDomainParam instanceof Error && ( ( Error ) baseDomainParam ) . getErrorCode ( ) > 0 ) { 
} private CloseableHttpClient getClient ( ) { 
if ( this . closeableHttpClient != null ) { 
return this . closeableHttpClient ; 
String pathToFluidTrustStore = this . getPathToFluidSpecificTrustStore ( ) ; 
if ( IS_IN_JUNIT_TEST_MODE || pathToFluidTrustStore != null ) { 
SSLContextBuilder builder = new SSLContextBuilder ( ) ; 
if ( pathToFluidTrustStore == null ) { 
builder . loadTrustMaterial ( new SSLTrustAll ( ) ) ; 
String password = this . getFluidSpecificTrustStorePassword ( ) ; 
if ( password == null ) { 
password = UtilGlobal . EMPTY ; 
if ( IS_IN_JUNIT_TEST_MODE ) { 
builder . loadTrustMaterial ( 
new File ( pathToFluidTrustStore ) , 
password . toCharArray ( ) , 
new SSLTrustAll ( ) ) ; 
password . toCharArray ( ) ) ; 
SSLContext sslContext = builder . build ( ) ; 
this . closeableHttpClient = HttpClients . custom ( ) . setSSLSocketFactory ( 
new SSLConnectionSocketFactory ( sslContext ) ) . build ( ) ; 
} catch ( NoSuchAlgorithmException e ) { 
e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} catch ( KeyManagementException e ) { 
FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} catch ( KeyStoreException e ) { 
} catch ( CertificateException e ) { 
this . closeableHttpClient = HttpClients . createDefault ( ) ; 
} private String getPathToFluidSpecificTrustStore ( ) { 
String fluidSystemTrustStore = 
System . getProperty ( SYSTEM_PROP_FLUID_TRUST_STORE ) ; 
if ( fluidSystemTrustStore == null || fluidSystemTrustStore . trim ( ) . isEmpty ( ) ) { 
File certFile = new File ( fluidSystemTrustStore ) ; 
if ( certFile . exists ( ) && certFile . isFile ( ) ) { 
return fluidSystemTrustStore ; 
} protected void closeConnectionNonThreaded ( ) { 
this . closeableHttpClient . close ( ) ; 
e . getMessage ( ) , 
e , FluidClientException . ErrorCode . IO_ERROR ) ; 
this . closeableHttpClient = null ; 
} public void closeConnection ( ) { 
if ( this . connection == null ) { 
if ( this . connection . isClosed ( ) ) { 
this . connection . close ( ) ; 
} catch ( SQLException sqlExcept ) { 
throw new FluidSQLException ( sqlExcept ) ; 
} public SQLServerType getSQLTypeFromConnection ( ) { 
if ( this . databaseMetaData == null ) { 
this . databaseMetaData = this . getConnection ( ) . getMetaData ( ) ; 
return SQLServerType . getSQLTypeFromProductName ( 
this . databaseMetaData . getDatabaseProductName ( ) ) ; 
} protected void closeStatement ( PreparedStatement preparedStatementParam , 
if ( resultSetParam == null ) { 
this . closeStatement ( preparedStatementParam ) ; 
resultSetParam . close ( ) ; 
} protected void closeStatement ( PreparedStatement preparedStatementParam ) { 
if ( preparedStatementParam == null ) 
preparedStatementParam . close ( ) ; 
} public FluidItem getFluidItemByFormId ( Long formIdParam ) { 
Form form = new Form ( formIdParam ) ; 
return new FluidItem ( this . postJson ( 
form , WS . Path . FlowItem . Version1 . getByForm ( ) ) ) ; 
} public FluidItem createFlowItem ( 
FluidItem flowJobItemParam , 
String flowNameParam ) { 
if ( flowJobItemParam != null && this . serviceTicket != null ) { 
flowJobItemParam . setServiceTicket ( this . serviceTicket ) ; 
if ( flowJobItemParam != null ) 
flowJobItemParam . setFlow ( flowNameParam ) ; 
return new FluidItem ( this . putJson ( 
flowJobItemParam , WS . Path . FlowItem . Version1 . flowItemCreate ( ) ) ) ; 
} public FluidItemListing getFluidItemsForView ( 
String sortFieldParam , 
String sortOrderParam ) 
if ( this . serviceTicket != null && jobViewParam != null ) 
WS . Path . FlowItem . Version1 . getByJobView ( 
sortFieldParam , 
sortOrderParam 
) ) ) ; 
} public FluidItem sendFlowItemOn ( 
boolean allowCollaboratorToSendOnParam 
flowJobItemParam , WS . Path . FlowItem . Version1 . sendFlowItemOn ( 
allowCollaboratorToSendOnParam ) ) ) ; 
} public FluidItem sendFormToFlow ( 
String flowParam ) { 
itemToSend . setFlow ( flowParam ) ; 
itemToSend . setServiceTicket ( this . serviceTicket ) ; 
itemToSend , WS . Path . FlowItem . Version1 . sendFlowItemToFlow ( ) ) ) ; 
} @ OnClose 
public void onClose ( Session userSessionParam , CloseReason reasonParam ) { 
this . userSession = null ; 
if ( this . messageHandlers != null ) { 
this . messageHandlers . values ( ) . forEach ( handle -> { 
handle . connectionClosed ( ) ; 
} @ OnMessage 
public void onMessage ( String messageParam ) { 
boolean handlerFoundForMsg = false ; 
for ( IMessageResponseHandler handler : new ArrayList < > ( this . messageHandlers . values ( ) ) ) { 
Object qualifyObj = handler . doesHandlerQualifyForProcessing ( messageParam ) ; 
if ( qualifyObj instanceof Error ) { 
handler . handleMessage ( qualifyObj ) ; 
} else if ( qualifyObj instanceof JSONObject ) { 
handlerFoundForMsg = true ; 
if ( ! handlerFoundForMsg ) { 
} public void sendMessage ( ABaseFluidJSONObject aBaseFluidJSONObjectParam ) { 
if ( aBaseFluidJSONObjectParam == null ) { 
this . sendMessage ( aBaseFluidJSONObjectParam . toJsonObject ( ) . toString ( ) ) ; 
} public void sendMessage ( String messageToSendParam ) { 
if ( this . userSession == null ) { 
RemoteEndpoint . Async asyncRemote = null ; 
if ( ( asyncRemote = this . userSession . getAsyncRemote ( ) ) == null ) { 
asyncRemote . sendText ( messageToSendParam ) ; 
} public void closeSession ( ) { 
this . userSession . close ( ) ; 
returnVal . put ( JSONMapping . ERROR_CODE , this . getErrorCode ( ) ) ; 
returnVal . put ( JSONMapping . ERROR_CODE_OTHER , this . getErrorCode ( ) ) ; 
if ( this . getErrorMessage ( ) != null ) 
returnVal . put ( JSONMapping . ERROR_MESSAGE , this . getErrorMessage ( ) ) ; 
returnVal . put ( JSONMapping . ERROR_MESSAGE_OTHER , this . getErrorMessage ( ) ) ; 
} public List < FormFieldListing > getFormFieldsSynchronized ( 
Form ... formsToGetFieldListingForForParam 
if ( formsToGetFieldListingForForParam == null ) { 
if ( formsToGetFieldListingForForParam . length == 0 ) { 
for ( Form formToSend : formsToGetFieldListingForForParam ) { 
List < FormFieldListing > returnValue = 
"SQLUtil-WebSocket-GetFormFields" , 
if ( this . getRuleExecuted ( ) != null ) 
returnVal . put ( JSONMapping . RULE_EXECUTED , 
this . getRuleExecuted ( ) ) ; 
if ( this . getRuleExecutedResult ( ) != null ) 
returnVal . put ( JSONMapping . RULE_EXECUTED_RESULT , 
this . getRuleExecutedResult ( ) ) ; 
if ( this . getFlowRuleOrder ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_RULE_ORDER , 
this . getFlowRuleOrder ( ) ) ; 
if ( this . getLogEntryType ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STEP , 
this . getFlowStep ( ) . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FORM , 
this . getForm ( ) . toJsonObject ( ) ) ; 
this . getJobView ( ) ) ; 
} public List < SQLResultSet > executeNativeSQLSynchronized ( 
NativeSQLQuery nativeSQLQueryParam ) { 
if ( nativeSQLQueryParam == null ) 
if ( nativeSQLQueryParam . getDatasourceName ( ) == null || 
nativeSQLQueryParam . getDatasourceName ( ) . isEmpty ( ) ) 
if ( ( nativeSQLQueryParam . getQuery ( ) == null || 
nativeSQLQueryParam . getQuery ( ) . isEmpty ( ) ) && 
( nativeSQLQueryParam . getStoredProcedure ( ) == null || 
nativeSQLQueryParam . getStoredProcedure ( ) . isEmpty ( ) ) ) 
this . setEchoIfNotSet ( nativeSQLQueryParam ) ; 
this . sendMessage ( nativeSQLQueryParam , uniqueReqId ) ; 
List < SQLResultSet > returnValue = 
if ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) 
} public static SyntaxFactory getInstance ( ) { 
if ( SyntaxFactory . syntaxFactory == null ) { 
SyntaxFactory . syntaxFactory = new SyntaxFactory ( ) ; 
return SyntaxFactory . syntaxFactory ; 
} public ISyntax getSyntaxFor ( 
ABaseSQLUtil . SQLServerType sqlTypeParam , 
String aliasParam ) { 
if ( ISyntax . ProcedureMapping . isStoredProcedureMapping ( aliasParam ) ) { 
return new StoredProcedureSyntax ( 
aliasParam , 
ISyntax . ProcedureMapping . getParamCountForAlias ( aliasParam ) ) ; 
throw new FluidSQLException ( 
} public ISyntax getFieldValueSyntaxFor ( 
SQLFormFieldUtil . FormFieldMapping formFieldMappingParam 
Long dataType = formFieldMappingParam . dataType ; 
switch ( dataType . intValue ( ) ) { 
return this . getSyntaxFor ( 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_1_Text ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_2_TrueFalse ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_3_ParagraphText ) ; 
if ( this . isPlain ( formFieldMappingParam . metaData ) ) 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_4_MultiChoice ) ; 
else if ( this . isSelectMany ( formFieldMappingParam . metaData ) ) 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldMultipleValue_4_MultiChoice ) ; 
dataType 
formFieldMappingParam . metaData + "'." ) ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_5_DateTime ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_6_Decimal ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_7_TableField ) ; 
case UtilGlobal . FieldTypeId . _8_TEXT_ENCRYPTED : 
} private boolean isPlain ( String textToCheckParam ) { 
String toCheckLower = textToCheckParam . toLowerCase ( ) ; 
return toCheckLower . startsWith ( PLAIN . toLowerCase ( ) ) ; 
} private boolean isSelectMany ( String textToCheckParam ) { 
return toCheckLower . startsWith ( SELECT_MANY . toLowerCase ( ) ) ; 
if ( this . getSqlColumns ( ) != null ) 
for ( SQLColumn toAdd : this . getSqlColumns ( ) ) 
returnVal . put ( JSONMapping . SQL_COLUMNS , jsonArray ) ; 
} public String requestLicense ( LicenseRequest licenseRequestParam ) { 
if ( licenseRequestParam != null && 
licenseRequestParam . setServiceTicket ( this . serviceTicket ) ; 
return this . executeTxtReceiveTxt ( 
( licenseRequestParam == null ) ? null : 
licenseRequestParam . toJsonObject ( ) . toString ( ) , 
Version1 . licenseRequest ( ) ) ; 
} public LicenseRequest applyLicense ( String licenseToApplyParam ) 
LicenseRequest liceReq = new LicenseRequest ( ) ; 
liceReq . setLicenseCipherText ( licenseToApplyParam ) ; 
liceReq . setServiceTicket ( this . serviceTicket ) ; 
return new LicenseRequest ( this . postJson ( 
liceReq , Version1 . licenseApply ( ) ) ) ; 
if ( this . getInputs ( ) != null ) 
for ( Field toAdd : this . getInputs ( ) ) 
returnVal . put ( JSONMapping . INPUTS , jsonArray ) ; 
if ( this . getRules ( ) != null ) 
for ( String toAdd : this . getRules ( ) ) 
jsonArray . put ( toAdd ) ; 
returnVal . put ( JSONMapping . RULES , jsonArray ) ; 
} public Field createFieldTextPlain ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) { 
routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; 
routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; 
} public Field createFieldTrueFalse ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . TrueFalse ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . TrueFalse . TRUE_FALSE ) ; 
} public Field createFieldParagraphTextPlain ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . PLAIN ) ; 
} public Field createFieldParagraphTextHTML ( Field routeFieldParam ) { 
routeFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; 
Field routeFieldParam , 
List < String > multiChoiceValuesParam 
if ( multiChoiceValuesParam == null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . MultipleChoice ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . PLAIN ) ; 
routeFieldParam . setFieldValue ( new MultiChoice ( multiChoiceValuesParam ) ) ; 
} public Field createFieldMultiChoiceSelectMany ( 
routeFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . SELECT_MANY ) ; 
} public Field createFieldDateTimeDate ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE ) ; 
} public Field createFieldDateTimeDateAndTime ( Field routeFieldParam ) { 
routeFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; 
} public Field createFieldDecimalPlain ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; 
} public Field updateFieldTextPlain ( Field routeFieldParam ) { 
routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; 
} public Field updateFieldTrueFalse ( Field routeFieldParam ) { 
} public Field updateFieldParagraphTextPlain ( Field routeFieldParam ) { 
} public Field updateFieldParagraphTextHTML ( Field routeFieldParam ) { 
} public Field updateFieldDateTimeDate ( Field routeFieldParam ) { 
} public Field updateFieldDateTimeDateAndTime ( Field routeFieldParam ) { 
} public Field updateFieldDecimalPlain ( Field routeFieldParam ) { 
} public Field updateFieldValue ( Field routeFieldValueParam ) { 
if ( routeFieldValueParam != null && this . serviceTicket != null ) { 
routeFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
routeFieldValueParam , Version1 . routeFieldUpdateValue ( ) ) ) ; 
} public Field createFieldValue ( 
Field routeFieldValueToCreateParam , 
FluidItem fluidItemParam ) { 
if ( routeFieldValueToCreateParam != null && this . serviceTicket != null ) { 
routeFieldValueToCreateParam . setServiceTicket ( this . serviceTicket ) ; 
Long fluidItmId = ( fluidItemParam == null ) ? null : fluidItemParam . getId ( ) ; 
routeFieldValueToCreateParam , 
Version1 . routeFieldCreateValue ( fluidItmId ) ) ) ; 
} public Field getFieldById ( Long fieldIdParam ) { 
Field field = new Field ( fieldIdParam ) ; 
field , Version1 . getById ( ) ) ) ; 
} public List < Field > getRouteFieldValuesBy ( FluidItem fluidItemParam ) { 
if ( this . serviceTicket != null && fluidItemParam != null ) { 
fluidItemParam . setServiceTicket ( this . serviceTicket ) ; 
return new RouteFieldListing ( this . postJson ( 
fluidItemParam , Version1 . getValuesBy ( ) ) ) . getListing ( ) ; 
return new Field ( this . postJson ( fieldParam , Version1 . routeFieldDelete ( ) ) ) ; 
} public Field forceDeleteField ( Field fieldParam ) { 
fieldParam , Version1 . routeFieldDelete ( true ) ) ) ; 
public List < Field > convertTo ( List < SQLFormFieldUtil . FormFieldMapping > formFieldMappingsParam ) 
if ( formFieldMappingsParam == null ) 
for ( SQLFormFieldUtil . FormFieldMapping mappingToConvert : formFieldMappingsParam ) 
returnVal . add ( this . convertTo ( mappingToConvert ) ) ; 
public Field convertTo ( SQLFormFieldUtil . FormFieldMapping formFieldMappingParam ) 
switch ( formFieldMappingParam . dataType . intValue ( ) ) 
return new Field ( 
formFieldMappingParam . formFieldId , 
null , Field . Type . Text ) ; 
null , Field . Type . TrueFalse ) ; 
Field . Type . MultipleChoice ) ; 
} public Configuration getConfigurationByKey ( String configurationKeyParam ) 
Configuration configuration = new Configuration ( ) ; 
configuration . setKey ( configurationKeyParam ) ; 
configuration . setServiceTicket ( this . serviceTicket ) ; 
return new Configuration ( this . postJson ( 
configuration , WS . Path . Configuration . Version1 . getByKey ( ) ) ) ; 
} public ConfigurationListing getAllConfigurations ( ) 
return new ConfigurationListing ( this . postJson ( 
configuration , WS . Path . Configuration . Version1 . getAllConfigurations ( ) ) ) ; 
if ( this . getMachineName ( ) != null ) 
returnVal . put ( JSONMapping . MACHINE_NAME , 
this . getMachineName ( ) ) ; 
if ( this . getLicenseCipherText ( ) != null ) 
returnVal . put ( JSONMapping . LICENSE_CIPHER_TEXT , 
this . getLicenseCipherText ( ) ) ; 
if ( this . getLicenseType ( ) != null ) 
returnVal . put ( JSONMapping . LICENSE_TYPE , 
this . getLicenseType ( ) ) ; 
if ( this . getUserCount ( ) != null ) 
returnVal . put ( JSONMapping . USER_COUNT , 
this . getUserCount ( ) ) ; 
if ( this . getDateValidFrom ( ) != null ) 
returnVal . put ( JSONMapping . DATE_VALID_FROM , 
this . getDateAsLongFromJson ( this . getDateValidFrom ( ) ) ) ; 
if ( this . getDateValidTo ( ) != null ) 
returnVal . put ( JSONMapping . DATE_VALID_TO , 
this . getDateAsLongFromJson ( this . getDateValidTo ( ) ) ) ; 
} public Form createFormContainerSynchronized ( 
Form formToCreateParam ) { 
if ( formToCreateParam == null ) 
if ( formToCreateParam . getEcho ( ) == null || formToCreateParam . getEcho ( ) . trim ( ) . isEmpty ( ) ) 
formToCreateParam . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
this . sendMessage ( formToCreateParam , uniqueReqId ) ; 
List < Form > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( 
for ( Client client : this . getIdentities ( ) ) 
returnVal . append ( client . getProvider ( ) ) ; 
} public Attachment createAttachment ( Attachment attachmentParam ) 
if ( attachmentParam != null && this . serviceTicket != null ) 
attachmentParam . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . putJson ( 
attachmentParam , WS . Path . Attachment . Version1 . attachmentCreate ( ) ) ) ; 
} public Attachment getAttachmentById ( 
Long attachmentIdParam , 
boolean includeAttachmentDataParam ) 
Attachment attachment = new Attachment ( attachmentIdParam ) ; 
attachment . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . postJson ( 
attachment , WS . Path . Attachment . Version1 . getById ( 
includeAttachmentDataParam ) ) ) ; 
} public List < Attachment > getAttachmentsByForm ( 
AttachmentListing returnedListing = 
new AttachmentListing ( postJson ( 
formParam , WS . Path . Attachment . Version1 . getAllByFormContainer ( 
includeAttachmentDataParam , false ) ) ) ; 
return ( returnedListing == null ) ? null : 
returnedListing . getListing ( ) ; 
} public Attachment deleteAttachment ( Attachment attachmentParam ) 
attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( ) ) ) ; 
} public Attachment forceDeleteAttachment ( Attachment attachmentParam ) 
attachmentParam , 
WS . Path . Attachment . Version1 . attachmentDelete ( true ) ) ) ; 
} public static boolean hasDifferentValue ( XsdStringRestrictions o1 , XsdStringRestrictions o2 ) { 
if ( o1 == null && o2 == null ) { 
String o1Value = null ; 
String o2Value ; 
if ( o1 != null ) { 
o1Value = o1 . getValue ( ) ; 
if ( o2 != null ) { 
o2Value = o2 . getValue ( ) ; 
return o2Value . equals ( o1Value ) ; 
} public void replaceUnsolvedAttributes ( NamedConcreteElement element ) { 
if ( element . getElement ( ) instanceof XsdAttributeGroup ) { 
attributeGroups . stream ( ) 
. filter ( attributeGroup -> attributeGroup instanceof UnsolvedReference && ( ( UnsolvedReference ) attributeGroup ) . getRef ( ) . equals ( element . getName ( ) ) ) 
. findFirst ( ) . ifPresent ( referenceBase -> { 
attributeGroups . remove ( referenceBase ) ; 
attributeGroups . add ( element ) ; 
attributes . addAll ( element . getElement ( ) . getElements ( ) ) ; 
element . getElement ( ) . setParent ( getOwner ( ) ) ; 
if ( element . getElement ( ) instanceof XsdAttribute ) { 
attributes . stream ( ) 
. filter ( attribute -> attribute instanceof UnsolvedReference && ( ( UnsolvedReference ) attribute ) . getRef ( ) . equals ( element . getName ( ) ) ) 
attributes . remove ( referenceBase ) ; 
attributes . add ( element ) ; 
public void replaceUnsolvedElements ( NamedConcreteElement elementWrapper ) { 
if ( elementWrapper . getElement ( ) instanceof XsdElement ) { 
super . replaceUnsolvedElements ( elementWrapper ) ; 
if ( elementWrapper . getElement ( ) instanceof XsdGroup ) { 
elements . add ( elementWrapper ) ; 
this . elements . removeIf ( element -> 
element instanceof UnsolvedReference && ( ( UnsolvedReference ) element ) . getRef ( ) . equals ( elementWrapper . getName ( ) ) 
} private void parseJarFile ( InputStream inputStream ) { 
Node schemaNode = getSchemaNode ( inputStream ) ; 
if ( isXsdSchema ( schemaNode ) ) { 
XsdSchema . parse ( this , schemaNode ) ; 
} catch ( SAXException | IOException | ParserConfigurationException e ) { 
} private void setClassLoader ( String jarPath ) { 
if ( ! jarPath . endsWith ( ".jar" ) ) { 
ClassLoader originalCl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
URL url = originalCl . getResource ( jarPath ) ; 
url = new URL ( "file:/" + jarPath ) ; 
ClassLoader urlCl = URLClassLoader . newInstance ( new URL [ ] { url } , originalCl ) ; 
Thread . currentThread ( ) . setContextClassLoader ( urlCl ) ; 
classLoader = urlCl ; 
} static ReferenceBase xsdAnnotationChildrenParse ( Node node , XsdAnnotationChildren annotationChildren ) { 
annotationChildren . content = xsdRawContentParse ( node ) ; 
return ReferenceBase . createFromXsd ( annotationChildren ) ; 
} boolean isXsdSchema ( Node node ) { 
String schemaNodeName = node . getNodeName ( ) ; 
return schemaNodeName . equals ( XsdSchema . XSD_TAG ) || schemaNodeName . equals ( XsdSchema . XS_TAG ) ; 
} void resolveRefs ( ) { 
Map < String , List < NamedConcreteElement > > concreteElementsMap = 
parseElements . stream ( ) 
. filter ( concreteElement -> concreteElement instanceof NamedConcreteElement ) 
. map ( concreteElement -> ( NamedConcreteElement ) concreteElement ) 
. collect ( groupingBy ( NamedConcreteElement :: getName ) ) ; 
unsolvedElements . forEach ( unsolvedElement -> replaceUnsolvedReference ( concreteElementsMap , unsolvedElement ) ) ; 
} private void replaceUnsolvedReference ( Map < String , List < NamedConcreteElement > > concreteElementsMap , UnsolvedReference unsolvedReference ) { 
List < NamedConcreteElement > concreteElements = concreteElementsMap . get ( unsolvedReference . getRef ( ) ) ; 
if ( concreteElements != null ) { 
Map < String , String > oldElementAttributes = unsolvedReference . getElement ( ) . getAttributesMap ( ) ; 
for ( NamedConcreteElement concreteElement : concreteElements ) { 
NamedConcreteElement substitutionElementWrapper ; 
if ( ! unsolvedReference . isTypeRef ( ) ) { 
XsdNamedElements substitutionElement = concreteElement . getElement ( ) . clone ( oldElementAttributes ) ; 
substitutionElementWrapper = ( NamedConcreteElement ) ReferenceBase . createFromXsd ( substitutionElement ) ; 
substitutionElementWrapper = concreteElement ; 
unsolvedReference . getParent ( ) . replaceUnsolvedElements ( substitutionElementWrapper ) ; 
storeUnsolvedItem ( unsolvedReference ) ; 
} private void storeUnsolvedItem ( UnsolvedReference unsolvedReference ) { 
if ( parserUnsolvedElementsMap . isEmpty ( ) ) { 
parserUnsolvedElementsMap . add ( new UnsolvedReferenceItem ( unsolvedReference ) ) ; 
Optional < UnsolvedReferenceItem > innerEntry = 
parserUnsolvedElementsMap . stream ( ) 
. filter ( unsolvedReferenceObj -> 
unsolvedReferenceObj . getUnsolvedReference ( ) 
. getRef ( ) 
. equals ( unsolvedReference . getRef ( ) ) ) 
if ( innerEntry . isPresent ( ) ) { 
innerEntry . ifPresent ( entry -> entry . getParents ( ) . add ( unsolvedReference . getParent ( ) ) ) ; 
} public void addFileToParse ( String schemaLocation ) { 
if ( ! schemaLocations . contains ( schemaLocation ) && schemaLocation . endsWith ( ".xsd" ) ) { 
schemaLocations . add ( schemaLocation ) ; 
} private void rule2 ( ) { 
if ( ! ( parent instanceof XsdSchema ) && name != null ) { 
} private void rule3 ( ) { 
if ( parent instanceof XsdSchema && name == null ) { 
} public static boolean hasDifferentValue ( XsdDoubleRestrictions o1 , XsdDoubleRestrictions o2 ) { 
double o1Value = Double . MAX_VALUE ; 
double o2Value ; 
return o2Value == o1Value ; 
} public List < XsdRestriction > getAllRestrictions ( ) { 
Map < String , XsdRestriction > restrictions = new HashMap < > ( ) ; 
Map < String , String > xsdBuiltinTypes = XsdParserCore . getXsdTypesToJava ( ) ; 
if ( restriction != null ) { 
restrictions . put ( xsdBuiltinTypes . get ( restriction . getBase ( ) ) , restriction ) ; 
if ( union != null ) { 
union . getUnionElements ( ) . forEach ( unionMember -> { 
XsdRestriction unionMemberRestriction = unionMember . getRestriction ( ) ; 
if ( unionMemberRestriction != null ) { 
XsdRestriction existingRestriction = restrictions . getOrDefault ( xsdBuiltinTypes . get ( unionMemberRestriction . getBase ( ) ) , null ) ; 
if ( existingRestriction != null ) { 
if ( existsRestrictionOverlap ( existingRestriction , unionMemberRestriction ) ) { 
updateExistingRestriction ( existingRestriction , unionMemberRestriction ) ; 
restrictions . put ( xsdBuiltinTypes . get ( unionMemberRestriction . getBase ( ) ) , unionMemberRestriction ) ; 
return new ArrayList < > ( restrictions . values ( ) ) ; 
} private void updateExistingRestriction ( XsdRestriction existing , XsdRestriction newRestriction ) { 
XsdPattern pattern = newRestriction . getPattern ( ) ; 
XsdMaxExclusive maxExclusive = newRestriction . getMaxExclusive ( ) ; 
XsdMaxInclusive maxInclusive = newRestriction . getMaxInclusive ( ) ; 
XsdMaxLength maxLength = newRestriction . getMaxLength ( ) ; 
XsdMinExclusive minExclusive = newRestriction . getMinExclusive ( ) ; 
XsdMinInclusive minInclusive = newRestriction . getMinInclusive ( ) ; 
XsdMinLength minLength = newRestriction . getMinLength ( ) ; 
XsdLength length = newRestriction . getLength ( ) ; 
XsdFractionDigits fractionDigits = newRestriction . getFractionDigits ( ) ; 
XsdTotalDigits totalDigits = newRestriction . getTotalDigits ( ) ; 
XsdWhiteSpace whiteSpace = newRestriction . getWhiteSpace ( ) ; 
if ( pattern != null ) { 
existing . setPattern ( pattern ) ; 
if ( maxExclusive != null ) { 
existing . setMaxExclusive ( maxExclusive ) ; 
if ( maxInclusive != null ) { 
existing . setMaxInclusive ( maxInclusive ) ; 
if ( maxLength != null ) { 
existing . setMaxLength ( maxLength ) ; 
if ( minExclusive != null ) { 
existing . setMinExclusive ( minExclusive ) ; 
if ( minInclusive != null ) { 
existing . setMinInclusive ( minInclusive ) ; 
if ( minLength != null ) { 
existing . setMinLength ( minLength ) ; 
if ( length != null ) { 
existing . setLength ( length ) ; 
if ( fractionDigits != null ) { 
existing . setFractionDigits ( fractionDigits ) ; 
if ( totalDigits != null ) { 
existing . setTotalDigits ( totalDigits ) ; 
if ( whiteSpace != null ) { 
existing . setWhiteSpace ( whiteSpace ) ; 
updateExistingRestrictionEnumerations ( existing , newRestriction ) ; 
} private void updateExistingRestrictionEnumerations ( XsdRestriction existing , XsdRestriction newRestriction ) { 
List < XsdEnumeration > existingEnumeration = existing . getEnumeration ( ) ; 
List < XsdEnumeration > newRestrictionEnumeration = newRestriction . getEnumeration ( ) ; 
if ( existingEnumeration == null ) { 
existing . setEnumeration ( newRestrictionEnumeration ) ; 
if ( newRestrictionEnumeration != null ) { 
for ( XsdEnumeration enumerationElem : newRestrictionEnumeration ) { 
if ( existingEnumeration . stream ( ) . noneMatch ( existingEnumerationElem -> existingEnumerationElem . getValue ( ) . equals ( enumerationElem . getValue ( ) ) ) ) { 
existingEnumeration . add ( enumerationElem ) ; 
} private boolean existsRestrictionOverlap ( XsdRestriction existing , XsdRestriction newRestriction ) { 
return hasDifferentValue ( existing . getPattern ( ) , newRestriction . getPattern ( ) ) || 
hasDifferentValue ( existing . getWhiteSpace ( ) , newRestriction . getWhiteSpace ( ) ) || 
hasDifferentValue ( existing . getTotalDigits ( ) , newRestriction . getTotalDigits ( ) ) || 
hasDifferentValue ( existing . getFractionDigits ( ) , newRestriction . getFractionDigits ( ) ) || 
hasDifferentValue ( existing . getMaxExclusive ( ) , newRestriction . getMaxExclusive ( ) ) || 
hasDifferentValue ( existing . getMaxInclusive ( ) , newRestriction . getMaxInclusive ( ) ) || 
hasDifferentValue ( existing . getMaxLength ( ) , newRestriction . getMaxLength ( ) ) || 
hasDifferentValue ( existing . getMinExclusive ( ) , newRestriction . getMinExclusive ( ) ) || 
hasDifferentValue ( existing . getMinInclusive ( ) , newRestriction . getMinInclusive ( ) ) || 
hasDifferentValue ( existing . getMinLength ( ) , newRestriction . getMinLength ( ) ) || 
hasDifferentValue ( existing . getLength ( ) , newRestriction . getLength ( ) ) ; 
if ( attributesMap . containsKey ( REF_TAG ) && ( simpleType != null || form != null || type != null ) ) { 
XsdAbstractElement element = elementWrapper . getElement ( ) ; 
if ( element instanceof XsdSimpleType && simpleType != null && type . equals ( elementWrapper . getName ( ) ) ) { 
this . simpleType = elementWrapper ; 
} private void parseFile ( String filePath ) { 
if ( ! new File ( filePath ) . exists ( ) ) { 
throw new FileNotFoundException ( ) ; 
Node schemaNode = getSchemaNode ( filePath ) ; 
} private Node getSchemaNode ( String filePath ) throws IOException , SAXException , ParserConfigurationException { 
Document doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . parse ( filePath ) ; 
return doc . getFirstChild ( ) ; 
} private void rule7 ( ) { 
if ( parent instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) { 
if ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) { 
public void replaceUnsolvedElements ( NamedConcreteElement element ) { 
super . replaceUnsolvedElements ( element ) ; 
XsdNamedElements elem = element . getElement ( ) ; 
boolean isComplexOrSimpleType = elem instanceof XsdComplexType || elem instanceof XsdSimpleType ; 
if ( this . type instanceof UnsolvedReference && isComplexOrSimpleType && ( ( UnsolvedReference ) this . type ) . getRef ( ) . equals ( element . getName ( ) ) ) { 
this . type = element ; 
elem . setParent ( this ) ; 
if ( this . substitutionGroup instanceof UnsolvedReference && elem instanceof XsdElement && ( ( UnsolvedReference ) this . substitutionGroup ) . getRef ( ) . equals ( element . getName ( ) ) ) { 
XsdElement xsdElement = ( XsdElement ) elem ; 
this . type = xsdElement . type ; 
this . simpleType = xsdElement . simpleType ; 
this . complexType = xsdElement . complexType ; 
this . substitutionGroup = element ; 
} static ReferenceBase xsdParseSkeleton ( Node node , XsdAbstractElement element ) { 
XsdParserCore parser = element . getParser ( ) ; 
if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { 
String nodeName = child . getNodeName ( ) ; 
BiFunction < XsdParserCore , Node , ReferenceBase > parserFunction = XsdParserCore . getParseMappers ( ) . get ( nodeName ) ; 
if ( parserFunction != null ) { 
XsdAbstractElement childElement = parserFunction . apply ( parser , child ) . getElement ( ) ; 
childElement . accept ( element . getVisitor ( ) ) ; 
childElement . validateSchemaRules ( ) ; 
ReferenceBase wrappedElement = ReferenceBase . createFromXsd ( element ) ; 
parser . addParsedElement ( wrappedElement ) ; 
return wrappedElement ; 
} protected static Map < String , String > convertNodeMap ( NamedNodeMap nodeMap ) { 
HashMap < String , String > attributesMapped = new HashMap < > ( ) ; 
for ( int i = 0 ; i < nodeMap . getLength ( ) ; i ++ ) { 
Node node = nodeMap . item ( i ) ; 
attributesMapped . put ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; 
return attributesMapped ; 
} public void replaceUnsolvedElements ( NamedConcreteElement element ) { 
List < ReferenceBase > elements = this . getElements ( ) ; 
if ( elements != null ) { 
elements . stream ( ) 
. filter ( referenceBase -> referenceBase instanceof UnsolvedReference ) 
. map ( referenceBase -> ( UnsolvedReference ) referenceBase ) 
. filter ( unsolvedReference -> unsolvedReference . getRef ( ) . equals ( element . getName ( ) ) ) 
. ifPresent ( oldElement -> elements . set ( elements . indexOf ( oldElement ) , element ) ) ; 
} static String xsdRawContentParse ( Node node ) { 
StringBuilder stringBuilder = new StringBuilder ( ) ; 
if ( child . getNodeType ( ) == Node . TEXT_NODE ) { 
stringBuilder . append ( child . getTextContent ( ) ) ; 
return stringBuilder . toString ( ) ; 
} public static boolean hasDifferentValue ( XsdIntegerRestrictions o1 , XsdIntegerRestrictions o2 ) { 
int o1Value = Integer . MAX_VALUE ; 
int o2Value ; 
} public static < T extends XsdEnum > T belongsToEnum ( final XsdEnum < T > instance , final String value ) { 
Optional < T > enumValue = Arrays . stream ( instance . getValues ( ) ) . filter ( enumField -> enumField . getValue ( ) . equals ( value ) ) . findFirst ( ) ; 
if ( enumValue . isPresent ( ) ) { 
return enumValue . get ( ) ; 
StringBuilder possibleValues = new StringBuilder ( ) ; 
String values = possibleValues . toString ( ) ; 
values = values . substring ( 0 , values . length ( ) - 2 ) ; 
values ) ; 
} static String maxOccursValidation ( String elementName , String value ) { 
if ( value . equals ( "unbounded" ) ) { 
validateNonNegativeInteger ( elementName , MAX_OCCURS_TAG , value ) ; 
} static Integer validateNonNegativeInteger ( String elementName , String attributeName , String value ) { 
int intValue = Integer . parseInt ( value ) ; 
if ( intValue < 0 ) { 
return intValue ; 
} public static Integer validateRequiredNonNegativeInteger ( String elementName , String attributeName , String value ) { 
if ( value == null ) throw new ParsingException ( attributeMissingMessage ( elementName , attributeName ) ) ; 
return validateNonNegativeInteger ( elementName , attributeName , value ) ; 
} public static Integer validateRequiredPositiveInteger ( String elementName , String attributeName , String value ) { 
return validatePositiveInteger ( elementName , attributeName , value ) ; 
} private static Double validateDouble ( String elementName , String attributeName , String value ) { 
return Double . parseDouble ( value ) ; 
} public static Double validateRequiredDouble ( String elementName , String attributeName , String value ) { 
return validateDouble ( elementName , attributeName , value ) ; 
} static String getFormDefaultValue ( XsdAbstractElement parent ) { 
if ( parent == null ) return null ; 
if ( parent instanceof XsdSchema ) { 
return ( ( XsdSchema ) parent ) . getElementFormDefault ( ) ; 
return getFormDefaultValue ( parent . getParent ( ) ) ; 
} static String getFinalDefaultValue ( XsdAbstractElement parent ) { 
return ( ( XsdSchema ) parent ) . getFinalDefault ( ) ; 
return getFinalDefaultValue ( parent . getParent ( ) ) ; 
} static String getBlockDefaultValue ( XsdAbstractElement parent ) { 
return ( ( XsdSchema ) parent ) . getBlockDefault ( ) ; 
return getBlockDefaultValue ( parent . getParent ( ) ) ; 
} public static ReferenceBase createFromXsd ( XsdAbstractElement element ) { 
String ref = getRef ( element ) ; 
String name = getName ( element ) ; 
if ( ! ( element instanceof XsdNamedElements ) ) { 
return new ConcreteElement ( element ) ; 
if ( ref == null ) { 
return new NamedConcreteElement ( ( XsdNamedElements ) element , name ) ; 
return new UnsolvedReference ( ( XsdNamedElements ) element ) ; 
String elemName = elem . getRawName ( ) ; 
if ( this . base instanceof UnsolvedReference && isComplexOrSimpleType && ( ( UnsolvedReference ) this . base ) . getRef ( ) . equals ( elemName ) ) { 
this . base = element ; 
if ( this . childElement instanceof UnsolvedReference && 
elem instanceof XsdGroup && ( ( UnsolvedReference ) this . childElement ) . getRef ( ) . equals ( elemName ) ) { 
this . childElement = element ; 
visitor . replaceUnsolvedAttributes ( element ) ; 
} public void addHeaderView ( View v , Object data , boolean isSelectable ) { 
final FixedViewInfo info = new FixedViewInfo ( ) ; 
FrameLayout fl = new FullWidthFixedViewLayout ( getContext ( ) ) ; 
fl . addView ( v ) ; 
info . view = v ; 
info . viewContainer = fl ; 
info . data = data ; 
info . isSelectable = isSelectable ; 
mHeaderViewInfos . add ( info ) ; 
if ( mAdapter != null ) { 
if ( ! ( mAdapter instanceof FooterViewGridAdapter ) ) { 
mAdapter = new FooterViewGridAdapter ( mHeaderViewInfos , mFooterViewInfos , mAdapter ) ; 
notifiyChanged ( ) ; 
} public boolean removeFooterView ( View v ) { 
if ( mFooterViewInfos . size ( ) > 0 ) { 
boolean result = false ; 
if ( mAdapter != null && ( ( FooterViewGridAdapter ) mAdapter ) . removeFooter ( v ) ) { 
removeFixedViewInfo ( v , mFooterViewInfos ) ; 
public boolean supportsParameter ( 
ParameterContext parameterContext , ExtensionContext extensionContext ) 
throws ParameterResolutionException { 
return parameterContext . getParameter ( ) . getAnnotation ( Random . class ) != null ; 
public Object resolveParameter ( 
parameterContext . getParameter ( ) . getType ( ) , 
parameterContext . getParameter ( ) . getAnnotation ( Random . class ) ) ; 
} private Object resolve ( Class < ? > targetType , Random annotation ) { 
if ( targetType . isAssignableFrom ( List . class ) || targetType . isAssignableFrom ( Collection . class ) ) { 
return random 
. objects ( annotation . type ( ) , annotation . size ( ) , annotation . excludes ( ) ) 
} else if ( targetType . isAssignableFrom ( Set . class ) ) { 
} else if ( targetType . isAssignableFrom ( Stream . class ) ) { 
return random . objects ( annotation . type ( ) , annotation . size ( ) , annotation . excludes ( ) ) ; 
return random . nextObject ( targetType , annotation . excludes ( ) ) ; 
} public File createFile ( String fileName ) throws IOException { 
Path path = Paths . get ( rootFolder . getPath ( ) , fileName ) ; 
return Files . createFile ( path ) . toFile ( ) ; 
} public File createDirectory ( String directoryName ) { 
Path path = Paths . get ( rootFolder . getPath ( ) , directoryName ) ; 
return Files . createDirectory ( path ) . toFile ( ) ; 
throw new TemporaryFolderException ( 
} void destroy ( ) throws IOException { 
if ( rootFolder . exists ( ) ) { 
Files . walkFileTree ( 
rootFolder . toPath ( ) , 
new SimpleFileVisitor < Path > ( ) { 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attributes ) 
return delete ( file ) ; 
public FileVisitResult postVisitDirectory ( Path directory , IOException exception ) 
return delete ( directory ) ; 
@ SuppressWarnings ( "SameReturnValue" ) 
private FileVisitResult delete ( Path file ) throws IOException { 
Files . delete ( file ) ; 
return CONTINUE ; 
Files . delete ( rootFolder . toPath ( ) ) ; 
return appliesTo ( parameterContext . getParameter ( ) . getType ( ) ) ; 
return extensionContext 
. getStore ( NAMESPACE ) 
. getOrComputeIfAbsent ( 
parameterContext , key -> new TemporaryFolder ( ) , TemporaryFolder . class ) ; 
} private Predicate < String > getPredicate ( ExpectedException annotation ) { 
if ( has ( annotation . messageStartsWith ( ) ) ) { 
return s -> s . startsWith ( annotation . messageStartsWith ( ) ) ; 
} else if ( has ( annotation . messageContains ( ) ) ) { 
return s -> s . contains ( annotation . messageContains ( ) ) ; 
} else if ( has ( annotation . messageIs ( ) ) ) { 
return s -> s . equals ( annotation . messageIs ( ) ) ; 
return s -> true ; 
} public static ExtensionContext . Store getStore ( ExtensionContext extensionContext , Class clazz ) { 
return extensionContext . getStore ( namespace ( extensionContext , clazz ) ) ; 
} private static ExtensionContext . Namespace namespace ( 
ExtensionContext extensionContext , Class clazz ) { 
return ExtensionContext . Namespace . create ( clazz , extensionContext ) ; 
public void beforeAll ( ExtensionContext extensionContext ) throws Exception { 
List < SystemProperty > systemProperties = 
getSystemProperties ( extensionContext . getRequiredTestClass ( ) ) ; 
if ( ! systemProperties . isEmpty ( ) ) { 
RestoreContext . Builder builder = RestoreContext . createBuilder ( ) ; 
for ( SystemProperty systemProperty : systemProperties ) { 
builder . addPropertyName ( systemProperty . name ( ) ) ; 
if ( System . getProperty ( systemProperty . name ( ) ) != null ) { 
builder . addRestoreProperty ( 
systemProperty . name ( ) , System . getProperty ( systemProperty . name ( ) ) ) ; 
set ( systemProperty ) ; 
writeRestoreContext ( extensionContext , builder . build ( ) ) ; 
public void afterAll ( ExtensionContext extensionContext ) throws Exception { 
RestoreContext restoreContext = readRestoreContext ( extensionContext ) ; 
if ( restoreContext != null ) { 
restoreContext . restore ( ) ; 
} private List < SystemProperty > getSystemProperties ( AnnotatedElement annotatedElement ) { 
List < SystemProperty > systemProperties = new ArrayList < > ( ) ; 
if ( isAnnotated ( annotatedElement , SystemProperties . class ) ) { 
systemProperties . addAll ( 
Arrays . asList ( annotatedElement . getAnnotation ( SystemProperties . class ) . value ( ) ) ) ; 
if ( isAnnotated ( annotatedElement , SystemProperty . class ) ) { 
systemProperties . add ( annotatedElement . getAnnotation ( SystemProperty . class ) ) ; 
return systemProperties ; 
} public void restore ( ) { 
for ( String propertyName : propertyNames ) { 
if ( restoreProperties . containsKey ( propertyName ) ) { 
System . setProperty ( propertyName , restoreProperties . get ( propertyName ) ) ; 
System . clearProperty ( propertyName ) ; 
} public Logger getLogger ( String name ) { 
String tag = name == null ? ANONYMOUS_TAG : name ; 
Logger logger = loggerMap . get ( tag ) ; 
if ( logger == null ) { 
Logger newInstance = new TimberAndroidLoggerAdapter ( tag ) ; 
Logger oldInstance = loggerMap . putIfAbsent ( tag , newInstance ) ; 
logger = oldInstance == null ? newInstance : oldInstance ; 
} public void trace ( String format , Object arg ) { 
formatAndLog ( Log . VERBOSE , format , arg ) ; 
} public void trace ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . VERBOSE , format , arg1 , arg2 ) ; 
} public void trace ( String format , Object ... argArray ) { 
formatAndLog ( Log . VERBOSE , format , argArray ) ; 
} public void trace ( String msg , Throwable t ) { 
log ( Log . VERBOSE , msg , t ) ; 
} public void debug ( String format , Object arg ) { 
formatAndLog ( Log . DEBUG , format , arg ) ; 
} public void debug ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . DEBUG , format , arg1 , arg2 ) ; 
} public void debug ( String format , Object ... argArray ) { 
formatAndLog ( Log . DEBUG , format , argArray ) ; 
} public void debug ( String msg , Throwable t ) { 
log ( Log . DEBUG , msg , t ) ; 
} public void info ( String format , Object arg ) { 
formatAndLog ( Log . INFO , format , arg ) ; 
} public void info ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . INFO , format , arg1 , arg2 ) ; 
} public void info ( String format , Object ... argArray ) { 
formatAndLog ( Log . INFO , format , argArray ) ; 
} public void info ( String msg , Throwable t ) { 
log ( Log . INFO , msg , t ) ; 
} public void warn ( String format , Object arg ) { 
formatAndLog ( Log . WARN , format , arg ) ; 
} public void warn ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . WARN , format , arg1 , arg2 ) ; 
} public void warn ( String format , Object ... argArray ) { 
formatAndLog ( Log . WARN , format , argArray ) ; 
} public void warn ( String msg , Throwable t ) { 
log ( Log . WARN , msg , t ) ; 
} public void error ( String format , Object arg ) { 
formatAndLog ( Log . ERROR , format , arg ) ; 
} public void error ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . ERROR , format , arg1 , arg2 ) ; 
} public void error ( String format , Object ... argArray ) { 
formatAndLog ( Log . ERROR , format , argArray ) ; 
} public void error ( String msg , Throwable t ) { 
log ( Log . ERROR , msg , t ) ; 
public ReadableInstant getLastModified ( 
ServletContext servletContext , 
HttpServletRequest request , 
Page page 
) throws ServletException , IOException { 
return AoArrays . maxNonNull ( 
page . getDateCreated ( ) , 
page . getDatePublished ( ) , 
page . getDateModified ( ) 
public boolean getAllowRobots ( ServletContext servletContext , HttpServletRequest request , HttpServletResponse response , Page page ) throws ServletException , IOException { 
return PageUtils . findAllowRobots ( servletContext , request , response , page ) ; 
FileInputStream fis = new FileInputStream ( new File ( "dic/word-with-attr.dic" ) ) ; 
final Set < String > words = new TreeSet < String > ( ) ; 
final int [ ] num = { 0 } ; 
FileLoading fl = new FileLoading ( ) { 
public void row ( String line , int n ) { 
words . add ( line . trim ( ) ) ; 
num [ 0 ] ++ ; 
Dictionary . load ( fis , fl ) ; 
fis = new FileInputStream ( new File ( "dic/words-rmmseg.dic" ) ) ; 
WriterRow wr = new WriterRow ( new File ( "dic/words-marge-sogou-no-attr-and-rmmseg.dic" ) ) ; 
for ( String word : words ) { 
wr . writerRow ( word ) ; 
wr . close ( ) ; 
int n = 1 ; 
usage ( ) ; 
Properties analyzers = new Properties ( ) ; 
analyzers . load ( new FileInputStream ( new File ( "analyzer.properties" ) ) ) ; 
String mode = System . getProperty ( "mode" , "complex" ) ; 
String a = System . getProperty ( "analyzer" , "mmseg4j" ) ; 
Analyzer analyzer = null ; 
String an = ( String ) analyzers . get ( a ) ; 
if ( an != null ) { 
analyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; 
mode = a ; 
n = Integer . parseInt ( args [ 1 ] ) ; 
File path = new File ( args [ 0 ] ) ; 
System . out . println ( "analyzer=" + analyzer . getClass ( ) . getName ( ) ) ; 
Effect ef = new Effect ( path , analyzer ) ; 
ef . run ( mode , n ) ; 
} protected File [ ] listWordsFiles ( ) { 
return dicPath . listFiles ( new FilenameFilter ( ) { 
return name . startsWith ( "words" ) && name . endsWith ( ".dic" ) ; 
} public static int load ( InputStream fin , FileLoading loading ) throws IOException { 
BufferedReader br = new BufferedReader ( 
new InputStreamReader ( new BufferedInputStream ( fin ) , "UTF-8" ) ) ; 
while ( ( line = br . readLine ( ) ) != null ) { 
if ( line == null || line . startsWith ( "#" ) ) { 
loading . row ( line , n ) ; 
} private static char [ ] tail ( String str ) { 
char [ ] cs = new char [ str . length ( ) - 1 ] ; 
str . getChars ( 1 , str . length ( ) , cs , 0 ) ; 
} private synchronized void addLastTime ( File wordsFile ) { 
if ( wordsFile != null ) { 
wordsLastTime . put ( wordsFile , wordsFile . lastModified ( ) ) ; 
} public synchronized boolean wordsFileIsChange ( ) { 
for ( Entry < File , Long > flt : wordsLastTime . entrySet ( ) ) { 
File words = flt . getKey ( ) ; 
if ( ! words . canRead ( ) ) { 
if ( words . lastModified ( ) > flt . getValue ( ) ) { 
File [ ] words = listWordsFiles ( ) ; 
if ( words != null ) { 
for ( File wordsFile : words ) { 
if ( ! wordsLastTime . containsKey ( wordsFile ) ) { 
} public synchronized boolean reload ( ) { 
Map < File , Long > oldWordsLastTime = new HashMap < File , Long > ( wordsLastTime ) ; 
Map < Character , CharNode > oldDict = dict ; 
Map < Character , Object > oldUnit = unit ; 
wordsLastTime . clear ( ) ; 
dict = loadDic ( dicPath ) ; 
unit = loadUnit ( dicPath ) ; 
lastLoadTime = System . currentTimeMillis ( ) ; 
wordsLastTime . putAll ( oldWordsLastTime ) ; 
dict = oldDict ; 
unit = oldUnit ; 
if ( log . isLoggable ( Level . WARNING ) ) { 
} public boolean match ( String word ) { 
if ( word == null || word . length ( ) < 2 ) { 
CharNode cn = dict . get ( word . charAt ( 0 ) ) ; 
return search ( cn , word . toCharArray ( ) , 0 , word . length ( ) - 1 ) >= 0 ; 
} public int search ( CharNode node , char [ ] sen , int offset , int tailLen ) { 
if ( node != null ) { 
return node . indexOf ( sen , offset , tailLen ) ; 
} public static File getDefalutPath ( ) { 
if ( defalutPath == null ) { 
String defPath = System . getProperty ( "mmseg.dic.path" ) ; 
if ( defPath == null ) { 
URL url = Dictionary . class . getClassLoader ( ) . getResource ( "data" ) ; 
defPath = url . getFile ( ) ; 
defPath = System . getProperty ( "user.dir" ) + "/data" ; 
defalutPath = new File ( defPath ) ; 
if ( ! defalutPath . exists ( ) ) { 
return defalutPath ; 
} private int readChars ( StringBuilder bufSentence , ReadChar readChar ) throws IOException { 
int data = - 1 ; 
while ( ( data = readNext ( ) ) != - 1 ) { 
int d = readChar . transform ( data ) ; 
if ( readChar . isRead ( d ) ) { 
bufSentence . appendCodePoint ( d ) ; 
num ++ ; 
pushBack ( data ) ; 
return num ; 
} private static char [ ] toChars ( StringBuilder bufSentence ) { 
char [ ] chs = new char [ bufSentence . length ( ) ] ; 
bufSentence . getChars ( 0 , bufSentence . length ( ) , chs , 0 ) ; 
return chs ; 
} private static int toAscii ( int codePoint ) { 
if ( ( codePoint >= 65296 && codePoint <= 65305 ) 
|| ( codePoint >= 65313 && codePoint <= 65338 ) 
|| ( codePoint >= 65345 && codePoint <= 65370 ) 
codePoint -= 65248 ; 
return codePoint ; 
System . out . println ( "Usage:" ) ; 
Seg seg = null ; 
Dictionary dic = Dictionary . getInstance ( ) ; 
if ( "simple" . equals ( mode ) ) { 
seg = new SimpleSeg ( dic ) ; 
seg = new ComplexSeg ( dic ) ; 
File [ ] txts = path . listFiles ( new FilenameFilter ( ) { 
return name . endsWith ( ".txt" ) ; 
long time = 0 ; 
for ( File txt : txts ) { 
MMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; 
Word word = null ; 
OutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + "." + mode + ".word" ) ) ) ; 
BufferedWriter bw = new BufferedWriter ( osw ) ; 
while ( ( word = mmSeg . next ( ) ) != null ) { 
bw . append ( new String ( word . getString ( ) ) ) . append ( "\r\n" ) ; 
time += System . currentTimeMillis ( ) - start ; 
} public int getLen ( ) { 
if ( len < 0 ) { 
len = 0 ; 
for ( Word word : words ) { 
if ( word != null ) { 
len += word . getLength ( ) ; 
} public int getCount ( ) { 
} public double getVariance ( ) { 
if ( variance < 0 ) { 
sum += Math . pow ( word . getLength ( ) - getAvgLen ( ) , 2 ) ; 
variance = sum / getCount ( ) ; 
return variance ; 
} public int getSumDegree ( ) { 
if ( sumDegree < 0 ) { 
if ( word != null && word . getDegree ( ) > - 1 ) { 
sum += word . getDegree ( ) ; 
sumDegree = sum ; 
return sumDegree ; 
} protected void printChunk ( List < Chunk > chunks ) { 
for ( Chunk ck : chunks ) { 
} protected int search ( char [ ] chs , int offset , int tailLen ) { 
if ( tailLen == 0 ) { 
CharNode cn = dic . head ( chs [ offset ] ) ; 
return search ( cn , chs , offset , tailLen ) ; 
} protected int search ( CharNode cn , char [ ] chs , int offset , int tailLen ) { 
if ( tailLen == 0 || cn == null ) { 
return dic . search ( cn , chs , offset , tailLen ) ; 
} protected int maxMatch ( CharNode [ ] cns , int cnIdx , char [ ] chs , int offset ) { 
CharNode cn = null ; 
if ( offset < chs . length ) { 
cn = dic . head ( chs [ offset ] ) ; 
cns [ cnIdx ] = cn ; 
return dic . maxMatch ( cn , chs , offset ) ; 
} protected void maxMatch ( CharNode [ ] cns , int cnIdx , char [ ] chs , int offset , ArrayList < Integer > [ ] tailLens , int tailLensIdx ) { 
dic . maxMatch ( cn , tailLens [ tailLensIdx ] , chs , offset ) ; 
String words = "sogou/SogouLabDic.dic" ; 
String charset = "GBK" ; 
words = args [ 0 ] ; 
File file = new File ( words ) ; 
File dist = new File ( "dic/word-with-attr.dic" ) ; 
DicTransform dt = new DicTransform ( ) ; 
dt . transform ( file , charset , dist , new NoAttr ( ) ) ; 
public boolean connectJdbcOnWithUrlAndDriverAndUsernameAndPassword ( String dataBaseId , String url , String driverClassName , String username , String password ) throws ReflectiveOperationException { 
SimpleDriverDataSource dataSource = new SimpleDriverDataSource ( ) ; 
dataSource . setUrl ( url ) ; 
dataSource . setDriverClass ( ( Class < Driver > ) Class . forName ( driverClassName ) ) ; 
this . templateMap . put ( dataBaseId , new JdbcTemplate ( dataSource ) ) ; 
} public boolean runInTheSql ( String database , final String sql ) { 
getDatabaseJdbcTemplate ( database ) . update ( sql ) ; 
} public String queryInWithSql ( String database , String sql ) { 
JdbcTemplate template = getDatabaseJdbcTemplate ( database ) ; 
if ( sql != null && ! sql . trim ( ) . toUpperCase ( ) . startsWith ( JdbcFixture . SELECT_COMMAND_PREFIX ) ) { 
return Objects . toString ( template . update ( sql ) ) ; 
List < String > results = template . queryForList ( sql , String . class ) ; 
if ( results == null || results . isEmpty ( ) ) { 
return results . get ( 0 ) ; 
public void postProcessInstance ( ManagedClassSPI managedClass , Object instance ) { 
if ( ! managedClass . getInstanceScope ( ) . equals ( InstanceScope . APPLICATION ) ) { 
if ( ! managedClass . getInstanceType ( ) . equals ( InstanceType . PROXY ) ) { 
Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; 
StringBuilder interfaceNames = new StringBuilder ( interfaceClasses [ 0 ] . getName ( ) ) ; 
for ( int i = 1 ; i < interfaceClasses . length ; ++ i ) { 
interfaceNames . append ( interfaceClasses [ i ] . getName ( ) ) ; 
} public boolean isEndReached ( ) { 
if ( to == null || from == null ) { 
if ( length == null ) { 
return to == length - 1 ; 
public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { 
if ( formalParameters . length != 1 ) { 
if ( formalParameters [ 0 ] instanceof ParameterizedType ) { 
Class < ? > type = ( Class < ? > ) formalParameters [ 0 ] ; 
Object [ ] arguments = new Object [ 1 ] ; 
if ( type . equals ( Form . class ) ) { 
arguments [ 0 ] = new FormImpl ( httpRequest ) ; 
else if ( type . equals ( FormIterator . class ) ) { 
arguments [ 0 ] = new FormIteratorImpl ( httpRequest ) ; 
else if ( type . equals ( UploadedFile . class ) ) { 
Form form = new FormImpl ( httpRequest ) ; 
arguments [ 0 ] = form . getUploadedFile ( ) ; 
else if ( type . equals ( UploadStream . class ) ) { 
threadLocal . set ( ( Closeable ) ( arguments [ 0 ] = getUploadStream ( httpRequest , formalParameters ) ) ) ; 
else if ( type . equals ( InputStream . class ) ) { 
threadLocal . set ( ( Closeable ) ( arguments [ 0 ] = getUploadStream ( httpRequest , formalParameters ) . openStream ( ) ) ) ; 
arguments [ 0 ] = new FormObject ( httpRequest , type ) . getValue ( ) ; 
return arguments ; 
} private static UploadStream getUploadStream ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException { 
FormIterator form = new FormIteratorImpl ( httpRequest ) ; 
if ( ! form . hasNext ( ) ) { 
Part part = form . next ( ) ; 
if ( ! ( part instanceof UploadStream ) ) { 
return ( UploadStream ) part ; 
public void init ( ServletConfig config ) throws UnavailableException { 
super . init ( config ) ; 
for ( ManagedMethodSPI managedMethod : container . getManagedMethods ( ) ) { 
if ( ! managedMethod . isRemotelyAccessible ( ) ) { 
if ( ! Types . isKindOf ( managedMethod . getReturnType ( ) , Resource . class ) ) { 
restMethods . put ( key ( managedMethod ) , managedMethod ) ; 
protected void handleRequest ( RequestContext context ) throws IOException { 
HttpServletRequest httpRequest = context . getRequest ( ) ; 
HttpServletResponse httpResponse = context . getResponse ( ) ; 
ArgumentsReader argumentsReader = null ; 
ManagedMethodSPI method = null ; 
method = restMethods . get ( key ( httpRequest . getPathInfo ( ) ) ) ; 
throw new NoSuchMethodException ( ) ; 
Type [ ] formalParameters = method . getParameterTypes ( ) ; 
argumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; 
Object [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; 
Object instance = container . getInstance ( method . getDeclaringClass ( ) ) ; 
value = method . invoke ( instance , arguments ) ; 
} catch ( AuthorizationException e ) { 
sendUnauthorized ( context ) ; 
sendNotFound ( context , e ) ; 
sendBadRequest ( context ) ; 
} catch ( InvocationException e ) { 
sendError ( context , e ) ; 
if ( argumentsReader != null ) { 
argumentsReader . clean ( ) ; 
httpResponse . setCharacterEncoding ( "UTF-8" ) ; 
if ( method . isVoid ( ) ) { 
httpResponse . setStatus ( HttpServletResponse . SC_NO_CONTENT ) ; 
ContentType contentType = valueWriterFactory . getContentTypeForValue ( value ) ; 
httpResponse . setStatus ( HttpServletResponse . SC_OK ) ; 
httpResponse . setContentType ( contentType . getValue ( ) ) ; 
ValueWriter valueWriter = valueWriterFactory . getValueWriter ( contentType ) ; 
valueWriter . write ( httpResponse , value ) ; 
} private static String key ( String requestPath ) { 
int queryParametersIndex = requestPath . lastIndexOf ( '?' ) ; 
if ( queryParametersIndex == - 1 ) { 
queryParametersIndex = requestPath . length ( ) ; 
int extensionIndex = requestPath . lastIndexOf ( '.' , queryParametersIndex ) ; 
if ( extensionIndex == - 1 ) { 
extensionIndex = queryParametersIndex ; 
return requestPath . substring ( 0 , extensionIndex ) ; 
} public static ContentType forFile ( File file ) { 
Params . notNull ( file , "File" ) ; 
ContentType contentType = FILE_TYPES . get ( Files . getExtension ( file ) ) ; 
if ( contentType == null ) { 
contentType = TEXT_HTML ; 
} public static ContentType valueOf ( String value ) { 
return ContentType . APPLICATION_JSON ; 
return new ContentType ( value ) ; 
} public boolean hasParameter ( String name , String value ) { 
return value . equals ( parameters . get ( name ) ) ; 
} public String getParameter ( String name ) { 
return parameters . get ( name ) ; 
} private static Map < String , String > parseParameters ( String expression ) { 
Map < String , String > parameters = new HashMap < > ( ) ; 
int parametersSeparatorIndex = 0 ; 
int valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; 
if ( valueSeparatorIndex == - 1 ) { 
String name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; 
++ valueSeparatorIndex ; 
parametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; 
if ( parametersSeparatorIndex == - 1 ) { 
parametersSeparatorIndex = expression . length ( ) ; 
if ( valueSeparatorIndex == parametersSeparatorIndex ) { 
if ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) { 
++ parametersSeparatorIndex ; 
if ( parameters . isEmpty ( ) ) { 
return parameters ; 
public void config ( Config config ) throws Exception { 
log . trace ( "config(Config.Element)" ) ; 
transactionManager . config ( config ) ; 
Config config = managedClass . getConfig ( ) ; 
if ( config == null ) { 
List < Config > fields = config . findChildren ( "instance-field" ) ; 
if ( ! fields . isEmpty ( ) && ! InstanceType . POJO . equals ( managedClass . getInstanceType ( ) ) ) { 
for ( Config field : fields ) { 
Classes . setFieldValue ( instance , field . getAttribute ( "name" ) , field . getAttribute ( "value" ) ) ; 
} private void scanAnnotations ( ) { 
boolean remoteType = false ; 
Controller controllerAnnotation = getAnnotation ( implementationClass , Controller . class ) ; 
if ( controllerAnnotation != null ) { 
remoteType = true ; 
requestPath = controllerAnnotation . value ( ) ; 
Service serviceAnnotation = getAnnotation ( implementationClass , Service . class ) ; 
if ( serviceAnnotation != null ) { 
requestPath = serviceAnnotation . value ( ) ; 
Remote remoteAnnotation = getAnnotation ( implementationClass , Remote . class ) ; 
if ( remoteAnnotation != null ) { 
RequestPath requestPathAnnotation = getAnnotation ( implementationClass , RequestPath . class ) ; 
if ( requestPathAnnotation != null ) { 
requestPath = requestPathAnnotation . value ( ) ; 
if ( requestPath != null && requestPath . isEmpty ( ) ) { 
requestPath = null ; 
if ( remoteType ) { 
remotelyAccessible = true ; 
boolean transactionalType = hasAnnotation ( implementationClass , Transactional . class ) ; 
boolean immutableType = hasAnnotation ( implementationClass , Immutable . class ) ; 
if ( ! transactionalType && immutableType ) { 
if ( transactionalType && ! instanceType . isPROXY ( ) ) { 
Class < ? extends Interceptor > classInterceptor = getInterceptorClass ( implementationClass ) ; 
boolean publicType = hasAnnotation ( implementationClass , Public . class ) ; 
for ( Method method : implementationClass . getDeclaredMethods ( ) ) { 
final int modifiers = method . getModifiers ( ) ; 
if ( Modifier . isStatic ( modifiers ) || ! Modifier . isPublic ( modifiers ) ) { 
Method interfaceMethod = getInterfaceMethod ( method ) ; 
ManagedMethod managedMethod = null ; 
boolean remoteMethod = hasAnnotation ( method , Remote . class ) ; 
if ( ! remoteMethod ) { 
remoteMethod = remoteType ; 
if ( hasAnnotation ( method , Local . class ) ) { 
remoteMethod = false ; 
if ( remoteMethod ) { 
Class < ? extends Interceptor > methodInterceptor = getInterceptorClass ( method ) ; 
if ( methodInterceptor == null ) { 
methodInterceptor = classInterceptor ; 
if ( methodInterceptor != null ) { 
if ( ! instanceType . isPROXY ( ) && ! remotelyAccessible ) { 
managedMethod = new ManagedMethod ( this , methodInterceptor , interfaceMethod ) ; 
boolean publicMethod = hasAnnotation ( method , Public . class ) ; 
if ( publicMethod && ! remotelyAccessible ) { 
if ( ! publicMethod ) { 
publicMethod = publicType ; 
if ( hasAnnotation ( method , Private . class ) ) { 
if ( ! remotelyAccessible ) { 
publicMethod = false ; 
RequestPath methodPath = getAnnotation ( method , RequestPath . class ) ; 
if ( ! remotelyAccessible && methodPath != null ) { 
if ( managedMethod == null ) { 
managedMethod = new ManagedMethod ( this , interfaceMethod ) ; 
managedMethod . setRequestPath ( methodPath != null ? methodPath . value ( ) : null ) ; 
managedMethod . setRemotelyAccessible ( remoteMethod ) ; 
managedMethod . setAccess ( publicMethod ? Access . PUBLIC : Access . PRIVATE ) ; 
if ( ! transactionalType ) { 
transactionalType = hasAnnotation ( method , Transactional . class ) ; 
if ( transactionalType ) { 
transactional = true ; 
if ( ! instanceType . isPROXY ( ) ) { 
boolean immutable = hasAnnotation ( method , Immutable . class ) ; 
if ( immutable && ! transactional ) { 
if ( ! immutable ) { 
immutable = immutableType ; 
if ( hasAnnotation ( method , Mutable . class ) ) { 
if ( ! transactional ) { 
immutable = false ; 
if ( instanceType . isPROXY ( ) && managedMethod == null ) { 
if ( transactional ) { 
managedMethod . setTransactional ( true ) ; 
managedMethod . setImmutable ( immutable ) ; 
boolean asynchronousMethod = hasAnnotation ( method , Asynchronous . class ) ; 
if ( asynchronousMethod ) { 
if ( ! Types . isVoid ( method . getReturnType ( ) ) ) { 
managedMethod . setAsynchronous ( asynchronousMethod ) ; 
Cron cronMethod = getAnnotation ( method , Cron . class ) ; 
if ( cronMethod != null ) { 
if ( remotelyAccessible ) { 
managedMethod . setCronExpression ( cronMethod . value ( ) ) ; 
cronMethodsPool . add ( managedMethod ) ; 
autoInstanceCreation = true ; 
if ( managedMethod != null ) { 
methodsPool . put ( interfaceMethod , managedMethod ) ; 
if ( managedMethod . isRemotelyAccessible ( ) && netMethodsPool . put ( method . getName ( ) , managedMethod ) != null ) { 
for ( Field field : implementationClass . getDeclaredFields ( ) ) { 
ContextParam contextParam = field . getAnnotation ( ContextParam . class ) ; 
if ( contextParam != null ) { 
contextParamFields . put ( contextParam . value ( ) , field ) ; 
} private Class < ? > loadImplementationClass ( Config descriptor ) throws ConfigException { 
String implementationName = descriptor . getAttribute ( "class" ) ; 
if ( implementationName == null ) { 
if ( instanceType . requiresImplementation ( ) ) { 
if ( ! instanceType . requiresImplementation ( ) ) { 
Class < ? > implementationClass = Classes . forOptionalName ( implementationName ) ; 
if ( implementationClass == null ) { 
if ( implementationClass . isInterface ( ) ) { 
int implementationModifiers = implementationClass . getModifiers ( ) ; 
if ( Modifier . isAbstract ( implementationModifiers ) ) { 
if ( Types . isKindOf ( implementationClass , ManagedLifeCycle . class ) && ! InstanceScope . APPLICATION . equals ( instanceScope ) ) { 
return implementationClass ; 
} private Class < ? > [ ] loadInterfaceClasses ( Config descriptor ) throws ConfigException { 
List < String > interfaceNames = new ArrayList < > ( ) ; 
if ( ! descriptor . hasChildren ( ) ) { 
if ( ! descriptor . hasAttribute ( "interface" ) ) { 
if ( instanceType . requiresInterface ( ) ) { 
return new Class < ? > [ ] { implementationClass } ; 
interfaceNames . add ( descriptor . getAttribute ( "interface" ) ) ; 
if ( "REMOTE" . equals ( descriptor . getAttribute ( "type" ) ) ) { 
String url = descriptor . getAttribute ( "url" ) ; 
if ( url == null || url . isEmpty ( ) ) { 
if ( url . startsWith ( "${" ) ) { 
for ( int i = 0 ; i < descriptor . getChildrenCount ( ) ; ++ i ) { 
String interfaceName = descriptor . getChild ( i ) . getAttribute ( "name" ) ; 
if ( interfaceName == null ) { 
interfaceNames . add ( interfaceName ) ; 
Class < ? > [ ] interfaceClasses = new Class < ? > [ interfaceNames . size ( ) ] ; 
for ( int i = 0 ; i < interfaceNames . size ( ) ; ++ i ) { 
final String interfaceName = interfaceNames . get ( i ) ; 
final Class < ? > interfaceClass = Classes . forOptionalName ( interfaceName ) ; 
if ( interfaceClass == null ) { 
if ( Types . isKindOf ( interfaceClass , ManagedLifeCycle . class ) ) { 
if ( instanceType . requiresInterface ( ) && ! interfaceClass . isInterface ( ) ) { 
if ( implementationClass != null && ! Types . isKindOf ( implementationClass , interfaceClass ) ) { 
interfaceClasses [ i ] = interfaceClass ; 
return interfaceClasses ; 
} private InstanceScope loadInstanceScope ( Config descriptor ) throws ConfigException { 
InstanceScope instanceScope = descriptor . getAttribute ( "scope" , InstanceScope . class , InstanceScope . APPLICATION ) ; 
if ( ! container . hasScopeFactory ( instanceScope ) ) { 
return instanceScope ; 
} private InstanceType loadInstanceType ( Config descriptor ) throws ConfigException { 
InstanceType instanceType = descriptor . getAttribute ( "type" , InstanceType . class , InstanceType . POJO ) ; 
if ( ! container . hasInstanceFactory ( instanceType ) ) { 
return instanceType ; 
} private String loadImplementationURL ( Config descriptor ) throws ConfigException { 
String implementationURL = descriptor . getAttribute ( "url" ) ; 
if ( instanceType . equals ( InstanceType . REMOTE ) && implementationURL == null ) { 
return implementationURL ; 
} private static Constructor < ? > getDeclaredConstructor ( Class < ? > implementationClass ) { 
Constructor < ? > [ ] declaredConstructors = ( Constructor < ? > [ ] ) implementationClass . getDeclaredConstructors ( ) ; 
if ( declaredConstructors . length == 0 ) { 
for ( Constructor < ? > declaredConstructor : declaredConstructors ) { 
if ( declaredConstructor . isSynthetic ( ) ) { 
if ( declaredConstructor . getParameterTypes ( ) . length == 0 ) { 
if ( declaredConstructor . getAnnotation ( Test . class ) != null ) { 
if ( constructor != null ) { 
constructor = declaredConstructor ; 
constructor = declaredConstructors [ 0 ] ; 
constructor . setAccessible ( true ) ; 
return constructor ; 
} private static Collection < Field > scanDependencies ( Class < ? > clazz ) { 
Collection < Field > dependencies = new ArrayList < > ( ) ; 
for ( Field field : clazz . getDeclaredFields ( ) ) { 
if ( ! field . isAnnotationPresent ( Inject . class ) ) { 
if ( Modifier . isFinal ( field . getModifiers ( ) ) ) { 
if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { 
dependencies . add ( field ) ; 
return dependencies ; 
} private void initializeStaticFields ( ) throws ConfigException { 
for ( Config config : config . findChildren ( "static-field" ) ) { 
String fieldName = config . getAttribute ( "name" ) ; 
if ( fieldName == null ) { 
if ( ! config . hasAttribute ( "value" ) ) { 
Field field = Classes . getOptionalField ( implementationClass , fieldName ) ; 
if ( field == null ) { 
int modifiers = field . getModifiers ( ) ; 
if ( ! Modifier . isStatic ( modifiers ) ) { 
Object value = config . getAttribute ( "value" , field . getType ( ) ) ; 
Classes . setFieldValue ( null , field , config . getAttribute ( "value" , field . getType ( ) ) ) ; 
} private String buildStringRepresentation ( Config descriptor ) { 
builder . append ( descriptor . getName ( ) ) ; 
builder . append ( ':' ) ; 
if ( implementationClass != null ) { 
builder . append ( implementationClass . getName ( ) ) ; 
for ( Class < ? > interfaceClass : interfaceClasses ) { 
builder . append ( interfaceClass . getName ( ) ) ; 
builder . append ( instanceType ) ; 
builder . append ( instanceScope ) ; 
builder . append ( remotelyAccessible ? "NET" : "LOCAL" ) ; 
if ( implementationURL != null ) { 
builder . append ( implementationURL ) ; 
} private static < T extends Annotation > T getAnnotation ( Class < ? > clazz , Class < T > annotationClass ) { 
T annotation = clazz . getAnnotation ( annotationClass ) ; 
for ( Class < ? > interfaceClass : clazz . getInterfaces ( ) ) { 
annotation = interfaceClass . getAnnotation ( annotationClass ) ; 
if ( annotation != null ) { 
return annotation ; 
} private static boolean hasAnnotation ( Class < ? > clazz , Class < ? extends Annotation > annotationClass ) { 
Annotation annotation = clazz . getAnnotation ( annotationClass ) ; 
} private static < T extends Annotation > T getAnnotation ( Method method , Class < T > annotationClass ) { 
T annotation = method . getAnnotation ( annotationClass ) ; 
for ( Class < ? > interfaceClass : method . getDeclaringClass ( ) . getInterfaces ( ) ) { 
annotation = interfaceClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) . getAnnotation ( annotationClass ) ; 
} catch ( NoSuchMethodException unused ) { 
} private static Method getInterfaceMethod ( Method method ) { 
return interfaceClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; 
} private static Class < ? extends Interceptor > getInterceptorClass ( Class < ? > clazz ) { 
Intercepted intercepted = getAnnotation ( clazz , Intercepted . class ) ; 
return intercepted != null ? intercepted . value ( ) : null ; 
} private static Class < ? extends Interceptor > getInterceptorClass ( Method method ) { 
Intercepted intercepted = getAnnotation ( method , Intercepted . class ) ; 
} private void setValue ( String propertyPath , Object value ) throws ConverterException , IllegalAccessException { 
List < String > nodeIDs = Strings . split ( propertyPath , '.' ) ; 
int lastNodeIndex = nodeIDs . size ( ) - 1 ; 
Node node = new ObjectNode ( object ) ; 
for ( int index = 0 ; index < lastNodeIndex ; index ++ ) { 
node = node . getChild ( nodeIDs . get ( index ) ) ; 
node . setValue ( nodeIDs . get ( lastNodeIndex ) , value ) ; 
} private static Class < ? > type ( Field field ) { 
if ( Types . isKindOf ( field . getType ( ) , List . class ) ) { 
return ( Class < ? > ) ( ( ParameterizedType ) field . getGenericType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; 
return field . getType ( ) ; 
protected static Object getDependencyValue ( ManagedClassSPI hostManagedClass , Class < ? > type ) { 
Stack < Class < ? > > stackTrace = dependenciesStack . get ( ) ; 
if ( stackTrace == null ) { 
stackTrace = new Stack < > ( ) ; 
dependenciesStack . set ( stackTrace ) ; 
ContainerSPI container = hostManagedClass . getContainer ( ) ; 
if ( stackTrace . contains ( type ) ) { 
stackTrace . add ( type ) ; 
for ( Class < ? > stackTraceClass : stackTrace ) { 
builder . append ( stackTraceClass . getName ( ) ) ; 
builder . append ( "\r\n" ) ; 
log . error ( builder . toString ( ) ) ; 
dependenciesStack . remove ( ) ; 
stackTrace . push ( type ) ; 
ManagedClassSPI dependencyManagedClass = container . getManagedClass ( type ) ; 
if ( isProxyRequired ( hostManagedClass , dependencyManagedClass ) ) { 
ScopeProxyHandler < ? > handler = new ScopeProxyHandler < > ( container , type ) ; 
return Proxy . newProxyInstance ( dependencyManagedClass . getImplementationClass ( ) . getClassLoader ( ) , dependencyManagedClass . getInterfaceClasses ( ) , handler ) ; 
Object value = container . getOptionalInstance ( ( Class < ? super Object > ) type ) ; 
if ( Types . isKindOf ( type , AppFactory . class ) ) { 
return container ; 
if ( Classes . isInstantiable ( type ) ) { 
return Classes . newInstance ( type ) ; 
stackTrace . pop ( ) ; 
} private static boolean isProxyRequired ( ManagedClassSPI hostManagedClass , ManagedClassSPI dependencyManagedClass ) { 
if ( dependencyManagedClass != null ) { 
InstanceScope dependencyScope = dependencyManagedClass . getInstanceScope ( ) ; 
if ( InstanceScope . THREAD . equals ( dependencyScope ) ) { 
return InstanceScope . APPLICATION . equals ( hostManagedClass . getInstanceScope ( ) ) ; 
return InstanceScope . SESSION . equals ( dependencyScope ) ; 
} StoppableObservable < TEntity > getObservable ( Scheduler scheduler ) { 
return runAsync ( scheduler , ( rx . Observer < ? super TEntity > observer , Subscription subscription ) -> { 
TEntity previousEntity ; 
previousEntity = read ( ) ; 
} catch ( IOException | IllegalArgumentException | IllegalAccessException ex ) { 
observer . onNext ( previousEntity ) ; 
while ( endCondition == null || ! endCondition . test ( previousEntity ) ) { 
sleep ( pollingInterval * 1000 ) ; 
if ( subscription . isUnsubscribed ( ) ) { 
TEntity newEntity ; 
newEntity = read ( ) ; 
if ( ! newEntity . equals ( previousEntity ) ) { 
observer . onNext ( newEntity ) ; 
previousEntity = newEntity ; 
observer . onCompleted ( ) ; 
} public final void setDefaultLink ( String rel , String ... hrefs ) { 
if ( hrefs == null || hrefs . length == 0 ) { 
defaultLinks . remove ( rel ) ; 
defaultLinks . put ( rel , 
stream ( hrefs ) . map ( uri :: resolve ) . collect ( toSet ( ) ) ) ; 
} public final void setDefaultLinkTemplate ( String rel , String href ) { 
if ( href == null ) { 
defaultLinkTemplates . remove ( rel ) ; 
defaultLinkTemplates . put ( rel , href ) ; 
} protected HttpResponse executeAndHandle ( Request request ) 
throws IOException , IllegalArgumentException , IllegalAccessException , FileNotFoundException , IllegalStateException { 
HttpResponse response = execute ( request ) ; 
handleResponse ( response , request ) ; 
} protected HttpResponse execute ( Request request ) 
defaultHeaders . forEach ( request :: addHeader ) ; 
return executor . execute ( request ) . returnResponse ( ) ; 
} protected void handleResponse ( HttpResponse response , Request request ) 
handleLinks ( response ) ; 
handleCapabilities ( response ) ; 
handleErrors ( response , request ) ; 
} protected void handleErrors ( HttpResponse response , Request request ) 
StatusLine statusLine = response . getStatusLine ( ) ; 
if ( statusLine . getStatusCode ( ) <= 299 ) { 
HttpEntity entity = response . getEntity ( ) ; 
String body ; 
if ( entity == null ) { 
body = null ; 
body = EntityUtils . toString ( entity ) ; 
Header contentType = entity . getContentType ( ) ; 
if ( ( contentType != null ) && contentType . getValue ( ) . startsWith ( "application/json" ) ) { 
JsonNode messageNode = serializer . readTree ( body ) . get ( "message" ) ; 
if ( messageNode != null ) { 
message = messageNode . asText ( ) ; 
} catch ( JsonProcessingException ex ) { 
Exception inner = ( body == null ) ? null : new HttpException ( body ) ; 
switch ( statusLine . getStatusCode ( ) ) { 
case HttpStatus . SC_BAD_REQUEST : 
throw new IllegalArgumentException ( message , inner ) ; 
case HttpStatus . SC_UNAUTHORIZED : 
throw new IllegalAccessException ( message ) ; 
case HttpStatus . SC_FORBIDDEN : 
case HttpStatus . SC_NOT_FOUND : 
case HttpStatus . SC_GONE : 
throw new FileNotFoundException ( message ) ; 
case HttpStatus . SC_CONFLICT : 
throw new IllegalStateException ( message , inner ) ; 
case HttpStatus . SC_PRECONDITION_FAILED : 
case HttpStatus . SC_REQUESTED_RANGE_NOT_SATISFIABLE : 
case HttpStatus . SC_REQUEST_TIMEOUT : 
throw new RuntimeException ( message , inner ) ; 
} @ SuppressWarnings ( "LocalVariableHidesMemberVariable" ) 
private void handleLinks ( HttpResponse response ) { 
Map < String , Map < URI , String > > links = new HashMap < > ( ) ; 
Map < String , String > linkTemplates = new HashMap < > ( ) ; 
handleHeaderLinks ( response , links , linkTemplates ) ; 
handleBodyLinks ( serializer . readTree ( entity . getContent ( ) ) , links , linkTemplates ) ; 
throw new RuntimeException ( ) ; 
this . links = unmodifiableMap ( links ) ; 
this . linkTemplates = unmodifiableMap ( linkTemplates ) ; 
} protected void handleHeaderLinks ( HttpResponse response , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { 
getLinkHeaders ( response ) . forEach ( header -> { 
if ( header . getRel ( ) == null ) { 
if ( header . isTemplated ( ) ) { 
linkTemplates . put ( header . getRel ( ) , header . getHref ( ) ) ; 
getOrAdd ( links , header . getRel ( ) ) 
. put ( uri . resolve ( header . getHref ( ) ) , header . getTitle ( ) ) ; 
} protected void handleBodyLinks ( JsonNode jsonBody , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { 
if ( jsonBody . getNodeType ( ) != JsonNodeType . OBJECT ) { 
JsonNode linksNode = jsonBody . get ( "_links" ) ; 
if ( linksNode == null ) { 
linksNode = jsonBody . get ( "links" ) ; 
linksNode . fields ( ) . forEachRemaining ( x -> { 
String rel = x . getKey ( ) ; 
Map < URI , String > linksForRel = getOrAdd ( links , rel ) ; 
switch ( x . getValue ( ) . getNodeType ( ) ) { 
x . getValue ( ) . forEach ( subobj -> { 
if ( subobj . getNodeType ( ) == JsonNodeType . OBJECT ) { 
parseLinkObject ( rel , ( ObjectNode ) subobj , linksForRel , linkTemplates ) ; 
parseLinkObject ( rel , ( ObjectNode ) x . getValue ( ) , linksForRel , linkTemplates ) ; 
} private void parseLinkObject ( String rel , ObjectNode obj , Map < URI , String > linksForRel , Map < String , String > linkTemplates ) { 
JsonNode href = obj . findValue ( "href" ) ; 
JsonNode templated = obj . findValue ( "templated" ) ; 
if ( templated != null && templated . isBoolean ( ) && templated . asBoolean ( ) ) { 
linkTemplates . put ( rel , href . asText ( ) ) ; 
JsonNode title = obj . findValue ( "title" ) ; 
linksForRel . put ( 
uri . resolve ( href . asText ( ) ) , 
( title != null && title . getNodeType ( ) == JsonNodeType . STRING ) ? title . asText ( ) : null ) ; 
} private static Map < URI , String > getOrAdd ( Map < String , Map < URI , String > > map , String key ) { 
Map < URI , String > value = map . get ( key ) ; 
map . put ( key , value = new HashMap < > ( ) ) ; 
} protected void handleCapabilities ( HttpResponse response ) { 
allowedMethods = unmodifiableSet ( stream ( response . getHeaders ( "Allow" ) ) 
. filter ( x -> x . getName ( ) . equals ( "Allow" ) ) 
. flatMap ( x -> stream ( x . getElements ( ) ) ) . map ( x -> x . getName ( ) ) 
. collect ( toSet ( ) ) ) ; 
} protected Optional < Boolean > isMethodAllowed ( String method ) { 
if ( allowedMethods . isEmpty ( ) ) { 
return Optional . of ( allowedMethods . contains ( method ) ) ; 
} @ SuppressWarnings ( "ThrowableResultIgnored" ) 
public static String getFullMessage ( Throwable throwable ) { 
builder . append ( throwable . getLocalizedMessage ( ) ) . append ( "\n" ) ; 
throwable = throwable . getCause ( ) ; 
} while ( throwable != null ) ; 
public < T > T newInstance ( ManagedClassSPI managedClass , Object ... args ) { 
return getRemoteInstance ( managedClass . getImplementationURL ( ) , ( Class < ? super T > ) managedClass . getInterfaceClass ( ) ) ; 
public < T > T getRemoteInstance ( String implementationURL , Class < ? super T > interfaceClass ) throws UnsupportedProtocolException { 
if ( implementationURL == null ) { 
String protocol = Strings . getProtocol ( implementationURL ) ; 
RemoteFactory remoteFactory = remoteFactories . get ( protocol ) ; 
if ( remoteFactory == null ) { 
return remoteFactory . getRemoteInstance ( implementationURL , interfaceClass ) ; 
} protected void registerInstanceProcessor ( ) { 
registerInstanceProcessor ( new InstanceFieldsInjectionProcessor ( ) ) ; 
registerInstanceProcessor ( new InstanceFieldsInitializationProcessor ( ) ) ; 
registerInstanceProcessor ( new ConfigurableInstanceProcessor ( ) ) ; 
registerInstanceProcessor ( new PostConstructInstanceProcessor ( ) ) ; 
registerInstanceProcessor ( new CronMethodsProcessor ( cronManager ) ) ; 
registerInstanceProcessor ( new LoggerInstanceProcessor ( ) ) ; 
} protected void registerScopeFactory ( ScopeFactory scopeFactory ) { 
if ( scopeFactory == null ) { 
scopeFactories . put ( InstanceScope . LOCAL , null ) ; 
final InstanceScope instanceScope = scopeFactory . getInstanceScope ( ) ; 
if ( scopeFactories . put ( instanceScope , scopeFactory ) != null ) { 
} protected void registerInstanceFactory ( InstanceType instanceType , InstanceFactory instanceFactory ) { 
if ( instanceFactories . put ( instanceType , instanceFactory ) != null ) { 
} protected void registerInstanceProcessor ( InstanceProcessor instanceProcessor ) { 
for ( InstanceProcessor existingInstanceProcessoor : instanceProcessors ) { 
if ( existingInstanceProcessoor . getClass ( ) . equals ( instanceProcessor . getClass ( ) ) ) { 
instanceProcessors . add ( instanceProcessor ) ; 
} protected void registerClassProcessor ( ClassProcessor classProcessor ) { 
for ( ClassProcessor existingClassProcessoor : classProcessors ) { 
if ( existingClassProcessoor . getClass ( ) . equals ( classProcessor . getClass ( ) ) ) { 
classProcessors . add ( classProcessor ) ; 
public void config ( Config config ) throws ConfigException { 
log . trace ( "config(Config)" ) ; 
List < Config > classDescriptors = new ArrayList < > ( ) ; 
for ( Config descriptorsSection : config . findChildren ( "managed-classes" , "web-sockets" ) ) { 
CLASS_DESCRIPTORS : for ( Config classDescriptor : descriptorsSection . getChildren ( ) ) { 
if ( ! classDescriptor . hasChildren ( ) ) { 
if ( ! classDescriptor . hasAttribute ( "interface" ) ) { 
classDescriptor . setAttribute ( "interface" , classDescriptor . getAttribute ( "class" ) ) ; 
String interfaceClass = classDescriptor . getAttribute ( "interface" ) ; 
for ( int i = 0 ; i < classDescriptors . size ( ) ; ++ i ) { 
if ( classDescriptors . get ( i ) . hasAttribute ( "interface" , interfaceClass ) ) { 
classDescriptors . set ( i , classDescriptor ) ; 
continue CLASS_DESCRIPTORS ; 
classDescriptors . add ( classDescriptor ) ; 
for ( Config classDescriptor : classDescriptors ) { 
ManagedClass managedClass = new ManagedClass ( this , classDescriptor ) ; 
for ( Class < ? > interfaceClass : managedClass . getInterfaceClasses ( ) ) { 
classesPool . put ( interfaceClass , managedClass ) ; 
for ( ClassProcessor classProcessor : classProcessors ) { 
classProcessor . postProcessClass ( managedClass ) ; 
convertersInitialization ( config ) ; 
pojoStaticInitialization ( config ) ; 
ManagedClassSPI appContext = classesPool . get ( AppContext . class ) ; 
if ( appContext != null && Types . isKindOf ( appContext . getImplementationClass ( ) , ContainerSPI . class ) ) { 
scopeFactories . get ( InstanceScope . APPLICATION ) . persistInstance ( new InstanceKey ( appContext . getKey ( ) ) , this ) ; 
log . trace ( "start()" ) ; 
Set < ManagedClassSPI > sortedClasses = new TreeSet < > ( new Comparator < ManagedClassSPI > ( ) { 
public int compare ( ManagedClassSPI o1 , ManagedClassSPI o2 ) { 
return o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ; 
for ( ManagedClassSPI managedClass : classesPool . values ( ) ) { 
if ( managedClass . isAutoInstanceCreation ( ) ) { 
sortedClasses . add ( managedClass ) ; 
for ( ManagedClassSPI managedClass : sortedClasses ) { 
getInstance ( ( Class < ? super Object > ) managedClass . getInterfaceClass ( ) ) ; 
log . trace ( "destroy()" ) ; 
cronManager . destroy ( ) ; 
return o2 . getKey ( ) . compareTo ( o1 . getKey ( ) ) ; 
if ( Types . isKindOf ( managedClass . getImplementationClass ( ) , ManagedPreDestroy . class ) ) { 
ScopeFactory scopeFactory = scopeFactories . get ( managedClass . getInstanceScope ( ) ) ; 
InstanceKey instanceKey = new InstanceKey ( managedClass . getKey ( ) ) ; 
Object instance = scopeFactory . getInstance ( instanceKey ) ; 
ManagedPreDestroy managedInstance = ( ManagedPreDestroy ) Classes . unproxy ( instance ) ; 
managedInstance . preDestroy ( ) ; 
for ( ScopeFactory scopeFactory : scopeFactories . values ( ) ) { 
if ( scopeFactory != null ) { 
scopeFactory . clear ( ) ; 
classesPool . clear ( ) ; 
instanceProcessors . clear ( ) ; 
scopeFactories . clear ( ) ; 
instanceFactories . clear ( ) ; 
public < T > T getInstance ( Class < ? super T > interfaceClass , Object ... args ) { 
ManagedClassSPI managedClass = classesPool . get ( interfaceClass ) ; 
if ( managedClass == null ) { 
return getInstance ( managedClass , instanceKey , args ) ; 
private < T > T getInstance ( ManagedClassSPI managedClass , InstanceKey instanceKey , Object ... args ) { 
InstanceFactory instanceFactory = instanceFactories . get ( managedClass . getInstanceType ( ) ) ; 
args = argumentsProcessor . preProcessArguments ( managedClass , args ) ; 
return instanceFactory . newInstance ( managedClass , args ) ; 
boolean postProcessingEnabled = false ; 
Object instance = null ; 
synchronized ( scopeMutex ) { 
instance = scopeFactory . getInstance ( instanceKey ) ; 
postProcessingEnabled = true ; 
instance = instanceFactory . newInstance ( managedClass , args ) ; 
scopeFactory . persistInstance ( instanceKey , instance ) ; 
if ( ! postProcessingEnabled ) { 
return ( T ) instance ; 
Object pojoInstance = null ; 
if ( instance instanceof Proxy ) { 
if ( Proxy . getInvocationHandler ( instance ) instanceof InstanceInvocationHandler ) { 
InstanceInvocationHandler < T > handler = ( InstanceInvocationHandler < T > ) Proxy . getInvocationHandler ( instance ) ; 
pojoInstance = handler . getWrappedInstance ( ) ; 
pojoInstance = instance ; 
if ( pojoInstance != null ) { 
for ( InstanceProcessor instanceProcessor : instanceProcessors ) { 
instanceProcessor . postProcessInstance ( managedClass , pojoInstance ) ; 
} private static void convertersInitialization ( Config config ) throws ConfigException { 
Config section = config . getChild ( "converters" ) ; 
for ( Config el : section . findChildren ( "type" ) ) { 
String className = el . getAttribute ( "class" ) ; 
Class < ? > valueType = Classes . forOptionalName ( className ) ; 
if ( valueType == null ) { 
String converterName = el . getAttribute ( "converter" ) ; 
Class < ? extends Converter > converterClass = Classes . forOptionalName ( converterName ) ; 
if ( converterClass == null ) { 
ConverterRegistry . getInstance ( ) . registerConverter ( valueType , converterClass ) ; 
} private static void pojoStaticInitialization ( Config config ) throws ConfigException { 
Config pojoClassesSection = config . getChild ( "pojo-classes" ) ; 
if ( pojoClassesSection == null ) { 
for ( Config pojoClassElement : pojoClassesSection . getChildren ( ) ) { 
String pojoClassName = pojoClassElement . getAttribute ( "class" ) ; 
if ( pojoClassName == null ) { 
Config configSection = config . getChild ( pojoClassElement . getName ( ) ) ; 
Class < ? > pojoClass = Classes . forOptionalName ( pojoClassName ) ; 
if ( pojoClass == null ) { 
if ( configSection == null ) { 
for ( Config staticElement : configSection . findChildren ( "static-field" ) ) { 
String fieldName = staticElement . getAttribute ( "name" ) ; 
if ( ! staticElement . hasAttribute ( "value" ) ) { 
Field staticField = Classes . getOptionalField ( pojoClass , fieldName ) ; 
if ( staticField == null ) { 
int modifiers = staticField . getModifiers ( ) ; 
Object value = staticElement . getAttribute ( "value" , staticField . getType ( ) ) ; 
Classes . setFieldValue ( null , staticField , value ) ; 
for ( Field dependency : managedClass . getDependencies ( ) ) { 
if ( dependency . isSynthetic ( ) ) { 
Classes . setFieldValue ( instance , dependency , getDependencyValue ( managedClass , dependency . getType ( ) ) ) ; 
} void setRequestPath ( String requestPath ) { 
this . requestPath = requestPath != null ? requestPath : Strings . toDashCase ( method . getName ( ) ) ; 
public < T > T invoke ( Object object , Object ... args ) throws AuthorizationException , IllegalArgumentException , InvocationException { 
if ( remotelyAccessible && ! isPublic ( ) && ! container . isAuthenticated ( ) ) { 
throw new AuthorizationException ( ) ; 
args = argumentsProcessor . preProcessArguments ( this , args ) ; 
if ( object instanceof Proxy ) { 
return ( T ) method . invoke ( object , args ) ; 
throw new InvocationException ( e . getTargetException ( ) ) ; 
if ( meter == null ) { 
return ( T ) invoker . invoke ( object , args ) ; 
meter . incrementInvocationsCount ( ) ; 
meter . startProcessing ( ) ; 
T returnValue = null ; 
returnValue = ( T ) invoker . invoke ( object , args ) ; 
meter . incrementExceptionsCount ( ) ; 
meter . stopProcessing ( ) ; 
if ( currentPart != null ) { 
currentPart . close ( ) ; 
if ( ! fileItemIterator . hasNext ( ) ) { 
FileItemStream fileItemStream = fileItemIterator . next ( ) ; 
if ( fileItemStream . isFormField ( ) ) { 
currentPart = new FormFieldImpl ( fileItemStream ) ; 
currentPart = new UploadStreamImpl ( fileItemStream ) ; 
} catch ( IOException | FileUploadException e ) { 
log . error ( e ) ; 
public ArgumentsReader getArgumentsReader ( HttpServletRequest httpRequest , Type [ ] formalParameters ) { 
if ( formalParameters . length == 0 ) { 
return EmptyArgumentsReader . getInstance ( ) ; 
if ( httpRequest . getQueryString ( ) != null ) { 
return readers . get ( null ) ; 
return getArgumentsReader ( httpRequest . getContentType ( ) , formalParameters [ 0 ] ) ; 
} private ArgumentsReader getArgumentsReader ( String contentType , Type parameterType ) { 
return readers . get ( EncoderKey . APPLICATION_JSON ) ; 
EncoderKey key = new EncoderKey ( ContentType . valueOf ( contentType ) , parameterType ) ; 
ArgumentsReader reader = readers . get ( key ) ; 
if ( reader != null ) { 
return reader ; 
key = new EncoderKey ( ContentType . valueOf ( contentType ) ) ; 
reader = readers . get ( key ) ; 
if ( reader == null ) { 
public ContentType getContentTypeForValue ( Object value ) { 
if ( value instanceof Document ) { 
return ContentType . TEXT_XML ; 
if ( value instanceof StreamHandler ) { 
return ContentType . APPLICATION_STREAM ; 
public ValueWriter getValueWriter ( ContentType contentType ) { 
ValueWriter writer = writers . get ( contentType ) ; 
return writer ; 
} StoppableObservable < TEntity > getObservable ( final long startIndex , Scheduler scheduler ) { 
long currentStartIndex = startIndex ; 
while ( ! subscription . isUnsubscribed ( ) ) { 
PartialResponse < TEntity > response ; 
response = ( currentStartIndex >= 0 ) 
? readRange ( currentStartIndex , null ) 
: readRange ( null , - currentStartIndex ) ; 
} catch ( IllegalStateException ex ) { 
} catch ( IOException | IllegalArgumentException | IllegalAccessException error ) { 
observer . onError ( error ) ; 
response . getElements ( ) . stream ( ) . forEach ( observer :: onNext ) ; 
if ( response . isEndReached ( ) ) { 
currentStartIndex = response . getTo ( ) + 1 ; 
public < T > T asObject ( String string , Class < T > valueType ) { 
return ( T ) new InstanceScope ( string ) ; 
} private void setField ( Field field , String parameterName , Object instance ) { 
final Object value = context . getProperty ( parameterName , field . getType ( ) ) ; 
field . set ( instance , value ) ; 
throw new BugError ( e ) ; 
Object [ ] arguments = new Object [ formalParameters . length ] ; 
int argumentIndex = 0 ; 
ServletFileUpload multipart = new ServletFileUpload ( ) ; 
FileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; 
FileItemStream fileItemStream = null ; 
fileItemStream = iterator . next ( ) ; 
String contentType = fileItemStream . getContentType ( ) ; 
Type parameterType = formalParameters [ argumentIndex ] ; 
ArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; 
boolean streamArgument = StreamFactory . isStream ( parameterType ) ; 
ArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; 
InputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; 
arguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; 
++ argumentIndex ; 
if ( streamArgument ) { 
threadLocal . set ( inputStream ) ; 
if ( argumentIndex != formalParameters . length ) { 
protected void serialize ( OutputStream outputStream ) throws IOException { 
Writer writer = new BufferedWriter ( new OutputStreamWriter ( outputStream , "UTF-8" ) ) ; 
TemplateEngine templateEngine = Classes . loadService ( TemplateEngine . class ) ; 
Template template = templateEngine . getTemplate ( meta . getTemplateFile ( ) ) ; 
boolean operatorSerialization = Boolean . parseBoolean ( meta . getProperty ( OPERATOR_SERIALIZATION ) ) ; 
if ( operatorSerialization ) { 
template . setProperty ( "js.template.serialize.operator" , true ) ; 
template . serialize ( model , writer ) ; 
public < T > T asObject ( String string , Class < T > valueType ) throws IllegalArgumentException , ConverterException { 
return ( T ) new InstanceType ( string ) ; 
return new Object [ ] { read ( httpRequest . getInputStream ( ) , formalParameters [ 0 ] ) } ; 
public Object read ( InputStream inputStream , Type type ) throws IOException { 
if ( Types . isKindOf ( type , Document . class ) ) { 
return documentBuilder . loadXML ( inputStream ) ; 
} else if ( Types . isKindOf ( type , InputStream . class ) ) { 
return inputStream ; 
public void write ( HttpServletResponse httpResponse , Object value ) throws IOException { 
final Document document = ( Document ) value ; 
document . serialize ( new OutputStreamWriter ( httpResponse . getOutputStream ( ) , "UTF-8" ) ) ; 
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { 
T instance = appFactory . getInstance ( interfaceClass ) ; 
return method . invoke ( instance , args ) ; 
} public void attach ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) { 
if ( requestURL == null ) { 
requestURL = httpRequest . getRequestURI ( ) ; 
if ( locale == null ) { 
locale = httpRequest . getLocale ( ) ; 
if ( requestPath == null ) { 
requestPath = httpRequest . getRequestURI ( ) . substring ( httpRequest . getContextPath ( ) . length ( ) ) ; 
this . httpRequest = httpRequest ; 
this . httpResponse = httpResponse ; 
this . attached = true ; 
} public void detach ( ) { 
attached = false ; 
locale = null ; 
securityDomain = null ; 
cookies = null ; 
requestURL = null ; 
} public Cookies getCookies ( ) { 
assertAttached ( ) ; 
if ( cookies == null ) { 
cookies = new Cookies ( httpRequest , httpResponse ) ; 
return cookies ; 
} public HttpSession getSession ( boolean ... create ) { 
if ( create . length == 0 ) { 
return httpRequest . getSession ( ) ; 
return httpRequest . getSession ( create [ 0 ] ) ; 
if ( ! attached ) { 
StringBuilder message = new StringBuilder ( ) ; 
message . append ( httpRequest . getRequestURI ( ) ) ; 
message . append ( "|:" ) ; 
message . append ( System . lineSeparator ( ) ) ; 
message . append ( httpRequest . getRemoteHost ( ) ) ; 
message . append ( httpRequest . getMethod ( ) ) ; 
message . append ( httpRequest . getQueryString ( ) ) ; 
Enumeration < String > headerNames = httpRequest . getHeaderNames ( ) ; 
String headerName = headerNames . nextElement ( ) ; 
message . append ( headerName ) ; 
message . append ( httpRequest . getHeader ( headerName ) ) ; 
log . error ( message . toString ( ) ) ; 
} private static List < InvocationMeter > getMeters ( ) { 
List < InvocationMeter > invocationMeters = new ArrayList < InvocationMeter > ( ) ; 
ContainerSPI container = ( ContainerSPI ) Factory . getAppFactory ( ) ; 
invocationMeters . add ( ( ( ManagedMethod ) managedMethod ) . getMeter ( ) ) ; 
return invocationMeters ; 
} protected void config ( EventStreamConfig config ) { 
if ( config . hasSecretKey ( ) ) { 
secretKey = config . getSecretKey ( ) ; 
if ( config . hasKeepAlivePeriod ( ) ) { 
keepAlivePeriod = config . getKeepAlivePeriod ( ) ; 
parameters = config . getParameters ( ) ; 
} public void push ( Event event ) { 
if ( ! active . get ( ) ) { 
if ( ! eventsQueue . offer ( event , EVENTS_QUEUE_PUSH_TIMEOUT , TimeUnit . MILLISECONDS ) ) { 
} catch ( InterruptedException unused ) { 
push ( new ShutdownEvent ( ) ) ; 
active . set ( false ) ; 
} protected void setRemoteHost ( String remoteHost ) { 
if ( string == null ) { 
string = Strings . concat ( '#' , STREAM_ID ++ , ':' , remoteHost ) ; 
} protected boolean loop ( ) { 
Event event = null ; 
event = eventsQueue . poll ( keepAlivePeriod , TimeUnit . MILLISECONDS ) ; 
sendKeepAlive ( ) ; 
return ! writer . checkError ( ) ; 
if ( event instanceof ShutdownEvent ) { 
sendEvent ( event ) ; 
onSent ( event ) ; 
} protected < T > T getParameter ( String name , Class < T > type ) { 
String value = parameters . get ( name ) ; 
return ConverterRegistry . getConverter ( ) . asObject ( value , type ) ; 
} protected void sendEvent ( Event event ) { 
write ( "data:" ) ; 
if ( secretKey == null ) { 
json . serialize ( writer , event ) ; 
Cipher cipher = Cipher . getInstance ( secretKey . getAlgorithm ( ) ) ; 
byte [ ] encryptedMessage = cipher . doFinal ( json . serialize ( event ) ) ; 
write ( Base64 . encode ( encryptedMessage ) ) ; 
} catch ( InvalidKeyException | NoSuchPaddingException | BadPaddingException | IllegalBlockSizeException e ) { 
crlf ( ) ; 
container = ( ContainerSPI ) config . getServletContext ( ) . getAttribute ( TinyContainer . ATTR_INSTANCE ) ; 
if ( container == null ) { 
servletName = Strings . concat ( config . getServletContext ( ) . getServletContextName ( ) , '#' , config . getServletName ( ) ) ; 
protected void service ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) throws IOException , ServletException { 
logContext . put ( LOG_CONTEXT_APP , httpRequest . getContextPath ( ) . isEmpty ( ) ? TinyContainer . ROOT_CONTEXT : httpRequest . getContextPath ( ) . substring ( 1 ) ) ; 
logContext . put ( LOG_CONTEXT_IP , httpRequest . getRemoteHost ( ) ) ; 
logContext . put ( LOG_CONTEXT_ID , Integer . toString ( requestID . getAndIncrement ( ) , Character . MAX_RADIX ) ) ; 
if ( isEmptyUriRequest ( httpRequest ) ) { 
String requestURI = httpRequest . getRequestURI ( ) ; 
Factory . bind ( container ) ; 
RequestContext context = container . getInstance ( RequestContext . class ) ; 
context . attach ( httpRequest , httpResponse ) ; 
handleRequest ( context ) ; 
} catch ( IOException | ServletException | Error | RuntimeException t ) { 
dumpError ( context , t ) ; 
logContext . clear ( ) ; 
context . detach ( ) ; 
} private static boolean isEmptyUriRequest ( HttpServletRequest httpRequest ) { 
if ( ! "GET" . equals ( httpRequest . getMethod ( ) ) ) { 
String acceptValue = httpRequest . getHeader ( HttpHeader . ACCEPT ) ; 
if ( acceptValue != null && acceptValue . contains ( ContentType . TEXT_HTML . getMIME ( ) ) ) { 
String referer = httpRequest . getHeader ( HttpHeader . REFERER ) ; 
if ( referer == null ) { 
StringBuilder uri = new StringBuilder ( httpRequest . getRequestURI ( ) ) ; 
String query = httpRequest . getQueryString ( ) ; 
if ( query . charAt ( 0 ) != '?' ) { 
uri . append ( '?' ) ; 
uri . append ( query ) ; 
return referer . toLowerCase ( ) . endsWith ( uri . toString ( ) . toLowerCase ( ) ) ; 
} protected static void sendUnauthorized ( RequestContext context ) { 
final ContainerSPI container = context . getContainer ( ) ; 
final HttpServletResponse httpResponse = context . getResponse ( ) ; 
if ( httpResponse . isCommitted ( ) ) { 
String loginPage = container . getLoginPage ( ) ; 
if ( HttpHeader . isXHR ( context . getRequest ( ) ) && loginPage != null ) { 
httpResponse . setHeader ( HttpHeader . X_HEADER_LOCATION , container . getLoginPage ( ) ) ; 
httpResponse . setStatus ( HttpServletResponse . SC_UNAUTHORIZED ) ; 
} protected static void sendBadRequest ( RequestContext context ) throws IOException { 
context . dump ( ) ; 
context . getResponse ( ) . sendError ( HttpServletResponse . SC_BAD_REQUEST , context . getRequestURI ( ) ) ; 
} protected static void sendNotFound ( RequestContext context , Exception exception ) throws IOException { 
sendJsonObject ( context , new RemoteException ( exception ) , HttpServletResponse . SC_NOT_FOUND ) ; 
} protected static void sendError ( RequestContext context , Throwable throwable ) throws IOException { 
if ( throwable instanceof InvocationException && throwable . getCause ( ) != null ) { 
if ( throwable instanceof InvocationTargetException ) { 
throwable = ( ( InvocationTargetException ) throwable ) . getTargetException ( ) ; 
if ( throwable instanceof BusinessException ) { 
sendJsonObject ( context , throwable , HttpServletResponse . SC_BAD_REQUEST ) ; 
dumpError ( context , throwable ) ; 
sendJsonObject ( context , new RemoteException ( throwable ) , HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; 
} protected static void dumpError ( RequestContext context , Throwable throwable ) { 
} protected static void sendJsonObject ( RequestContext context , Object object , int statusCode ) throws IOException { 
Json json = Classes . loadService ( Json . class ) ; 
String buffer = json . stringify ( object ) ; 
byte [ ] bytes = buffer . getBytes ( "UTF-8" ) ; 
httpResponse . setStatus ( statusCode ) ; 
httpResponse . setContentType ( ContentType . APPLICATION_JSON . getValue ( ) ) ; 
httpResponse . setContentLength ( bytes . length ) ; 
httpResponse . setHeader ( "Content-Language" , context . getLocale ( ) . toLanguageTag ( ) ) ; 
httpResponse . getOutputStream ( ) . write ( bytes ) ; 
httpResponse . getOutputStream ( ) . flush ( ) ; 
( ( StreamHandler < ? > ) value ) . invokeHandler ( httpResponse . getOutputStream ( ) ) ; 
} public void setSaveEnabled ( boolean val ) { 
saveButton . setVisible ( val ) ; 
setReadOnly ( ! val ) ; 
entityForm . setReadOnly ( ! val ) ; 
} protected void delete ( ) { 
ConfirmDialog . show ( getUI ( ) , question , ( ConfirmDialog cd ) -> { 
if ( cd . isConfirmed ( ) ) { 
onDelete ( ) ; 
} catch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { 
onError ( ex ) ; 
} catch ( RuntimeException ex ) { 
getUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; 
} protected void onDelete ( ) 
endpoint . delete ( ) ; 
eventBus . post ( new ElementDeletedEvent < > ( endpoint ) ) ; 
Constructor < ? > constructor = managedClass . getConstructor ( ) ; 
instance = constructor . newInstance ( args ) ; 
throw new InvocationException ( e ) ; 
if ( managedClass . getInstanceType ( ) . equals ( InstanceType . PROXY ) ) { 
ManagedProxyHandler handler = null ; 
if ( managedClass . isTransactional ( ) ) { 
TransactionalResource transactionalResource = managedClass . getContainer ( ) . getInstance ( TransactionalResource . class ) ; 
handler = new ManagedProxyHandler ( transactionalResource , managedClass , instance ) ; 
handler = new ManagedProxyHandler ( managedClass , instance ) ; 
final ClassLoader classLoader = managedClass . getImplementationClass ( ) . getClassLoader ( ) ; 
final Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; 
return ( T ) Proxy . newProxyInstance ( classLoader , interfaceClasses , handler ) ; 
} public static Iterable < LinkHeader > getLinkHeaders ( HttpResponse response ) { 
return stream ( response . getHeaders ( "Link" ) ) 
. flatMap ( x -> stream ( x . getElements ( ) ) . map ( LinkHeader :: new ) ) 
. collect ( toList ( ) ) ; 
QueryParametersParser queryParameters = new QueryParametersParser ( httpRequest . getInputStream ( ) ) ; 
return queryParameters . getArguments ( formalParameters ) ; 
} catch ( SyntaxException e ) { 
json . stringify ( new OutputStreamWriter ( httpResponse . getOutputStream ( ) , "UTF-8" ) , value ) ; 
} public static < T > T getInstance ( Class < T > interfaceClass , Object ... args ) { 
return getAppFactory ( ) . getInstance ( interfaceClass , args ) ; 
} public static < T > T getInstance ( String instanceName , Class < T > interfaceClass , Object ... args ) { 
return getAppFactory ( ) . getInstance ( instanceName , interfaceClass , args ) ; 
} public static < T > T getOptionalInstance ( Class < T > interfaceClass , Object ... args ) { 
return getAppFactory ( ) . getOptionalInstance ( interfaceClass , args ) ; 
} public static < T > T getRemoteInstance ( String implementationURL , Class < ? super T > interfaceClass ) { 
return getAppFactory ( ) . getRemoteInstance ( implementationURL , interfaceClass ) ; 
} public static AppFactory getAppFactory ( ) { 
AppFactory appFactory = tls . get ( ) ; 
if ( appFactory == null ) { 
return appFactory ; 
} public static void addFilterRow ( Grid grid ) { 
if ( grid . getHeaderRowCount ( ) < 2 ) { 
grid . appendHeaderRow ( ) ; 
Grid . HeaderRow headerRow = grid . getHeaderRow ( 1 ) ; 
Container . Indexed container = grid . getContainerDataSource ( ) ; 
container . getContainerPropertyIds ( ) . forEach ( pid -> { 
TextField filterField = new TextField ( ) ; 
filterField . setInputPrompt ( "Filter" ) ; 
filterField . addStyleName ( ValoTheme . TEXTFIELD_SMALL ) ; 
filterField . setWidth ( 100 , Sizeable . Unit . PERCENTAGE ) ; 
filterField . addTextChangeListener ( event -> { 
( ( Container . SimpleFilterable ) container ) . removeContainerFilters ( pid ) ; 
if ( ! event . getText ( ) . isEmpty ( ) ) { 
( ( Container . Filterable ) container ) . addContainerFilter ( new SimpleStringFilter ( pid , event . getText ( ) , true , false ) ) ; 
headerRow . getCell ( pid ) . setComponent ( filterField ) ; 
public < I > I newInstance ( ManagedClassSPI managedClass , Object ... args ) { 
if ( interfaceClasses == null ) { 
if ( interfaceClasses . length != 1 ) { 
return ( I ) Classes . loadService ( interfaceClasses [ 0 ] ) ; 
} public void setCandidates ( Collection < T > candidates ) { 
twinColSelect . setContainerDataSource ( 
container = new BeanItemContainer < > ( entityType , candidates ) ) ; 
} protected static void loadXML ( InputStream inputStream , Loader loader ) throws ConfigException { 
SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; 
SAXParser parser = factory . newSAXParser ( ) ; 
XMLReader reader = parser . getXMLReader ( ) ; 
reader . setContentHandler ( loader ) ; 
reader . parse ( new InputSource ( inputStream ) ) ; 
} protected void onError ( Exception ex ) { 
Notification . show ( "Error" , ex . getLocalizedMessage ( ) , Notification . Type . ERROR_MESSAGE ) ; 
} protected Component buildAndBind ( Class < TEntity > entityType ) { 
FormLayout layout = new FormLayout ( ) ; 
getPropertiesWithoutAnnotation ( entityType , EditorHidden . class ) . forEach ( ( property ) -> { 
if ( property . getWriteMethod ( ) == null ) { 
Component component = buildAndBind ( property ) ; 
component . setWidth ( 100 , Unit . PERCENTAGE ) ; 
if ( component . getCaption ( ) == null ) { 
component . setCaption ( propertyIdToHumanFriendly ( property . getName ( ) ) ) ; 
if ( component instanceof DateField ) { 
( ( DateField ) component ) . setResolution ( Resolution . SECOND ) ; 
layout . addComponent ( component ) ; 
getAnnotation ( entityType , property , Description . class ) 
. ifPresent ( x -> layout . addComponent ( buildDescriptionComponent ( property , x . value ( ) ) ) ) ; 
} private static List < Parameter > parse ( Reader reader ) throws IOException { 
List < Parameter > parameters = new ArrayList < Parameter > ( ) ; 
Parameter parameter = new Parameter ( ) ; 
State state = State . NAME ; 
int b = reader . read ( ) ; 
if ( b == - 1 ) { 
if ( parameter . isEmpty ( ) ) { 
if ( parameters . isEmpty ( ) && parameter . isRawValue ( ) ) { 
parameter . commitRawValue ( ) ; 
parameter . commitValue ( ) ; 
parameters . add ( parameter ) ; 
char c = ( char ) b ; 
case NAME : 
case '=' : 
state = State . VALUE ; 
parameter . commitName ( ) ; 
if ( parameter . getBuilder ( ) . isEmpty ( ) ) { 
parameter . append ( c ) ; 
case VALUE : 
state = State . NAME ; 
parameter = new Parameter ( ) ; 
} public Object [ ] getArguments ( Type [ ] formalParameters ) { 
if ( isObject ( formalParameters ) ) { 
Object object = Classes . newInstance ( type ) ; 
Field field = Classes . getField ( type , Strings . toMemberName ( parameter . getName ( ) ) ) ; 
Classes . setFieldValue ( object , field , asObject ( parameter . getValue ( ) , field . getType ( ) ) ) ; 
return new Object [ ] { object } ; 
int i = 0 , argumentsCount = Math . min ( formalParameters . length , parameters . size ( ) ) ; 
for ( i = 0 ; i < argumentsCount ; ++ i ) { 
arguments [ i ] = asObject ( parameters . get ( i ) . getValue ( ) , formalParameters [ i ] ) ; 
for ( ; i < formalParameters . length ; ++ i ) { 
arguments [ i ] = null ; 
for ( ; i < parameters . size ( ) ; ++ i ) { 
private static < T > T asObject ( String value , Type type ) { 
return ( T ) Types . getEmptyValue ( type ) ; 
if ( ! Types . isArrayLike ( type ) ) { 
if ( ! ( type instanceof Class ) ) { 
if ( ConverterRegistry . hasType ( type ) ) { 
return ConverterRegistry . getConverter ( ) . asObject ( value , ( Class < T > ) type ) ; 
List < String > strings = Strings . split ( value , ',' ) ; 
if ( type == String [ ] . class ) { 
return ( T ) strings . toArray ( new String [ strings . size ( ) ] ) ; 
if ( Types . isKindOf ( type , Collection . class ) ) { 
Type collectionType = type ; 
Class < ? > itemType = String . class ; 
if ( type instanceof ParameterizedType ) { 
collectionType = ( ( ParameterizedType ) type ) . getRawType ( ) ; 
itemType = ( Class < ? > ) ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) [ 0 ] ; 
Collection < Object > collection = Classes . newCollection ( collectionType ) ; 
Converter converter = ConverterRegistry . getConverter ( ) ; 
for ( String s : strings ) { 
collection . add ( converter . asObject ( s . trim ( ) , itemType ) ) ; 
return ( T ) collection ; 
} private static boolean isObject ( Type [ ] formalParameters ) { 
final Type type = formalParameters [ 0 ] ; 
if ( Types . isPrimitive ( type ) ) { 
if ( Types . isArrayLike ( type ) ) { 
if ( Types . isMap ( type ) ) { 
JsonReader reader = new JsonReader ( httpRequest . getInputStream ( ) , expectedStartSequence ( formalParameters ) ) ; 
return json . parse ( reader , formalParameters ) ; 
} catch ( JsonException e ) { 
return json . parse ( new InputStreamReader ( inputStream , "UTF-8" ) , type ) ; 
} catch ( JsonException | ClassCastException | UnsupportedEncodingException e ) { 
} public Object [ ] preProcessArguments ( ManagedClassSPI managedClass , Object ... args ) { 
if ( args == null ) { 
args = EMPTY_ARGS ; 
if ( managedClass . getImplementationClass ( ) == null ) { 
return args ; 
final Class < ? > [ ] types = constructor . getParameterTypes ( ) ; 
return preProcessArguments ( managedClass , constructor , types , args ) ; 
} public Object [ ] preProcessArguments ( ManagedMethodSPI managedMethod , Object ... args ) { 
final ManagedClassSPI managedClass = managedMethod . getDeclaringClass ( ) ; 
final Method method = managedMethod . getMethod ( ) ; 
final Class < ? > [ ] types = method . getParameterTypes ( ) ; 
return preProcessArguments ( managedClass , method , types , args ) ; 
} private static Object [ ] preProcessArguments ( ManagedClassSPI managedClass , Member member , Class < ? > [ ] formalParameters , Object ... args ) { 
switch ( args . length ) { 
args = new Object [ formalParameters . length ] ; 
args [ i ] = getDependencyValue ( managedClass , formalParameters [ i ] ) ; 
if ( args [ 0 ] instanceof VarArgs && formalParameters . length == 1 && formalParameters [ 0 ] . isArray ( ) ) { 
args [ 0 ] = ( ( VarArgs < ? > ) args [ 0 ] ) . getArguments ( ) ; 
if ( formalParameters . length != args . length ) { 
for ( int i = 0 ; i < formalParameters . length ; ++ i ) { 
if ( args [ i ] != null && ! Types . isInstanceOf ( args [ i ] , formalParameters [ i ] ) ) { 
} public static boolean isXHR ( HttpServletRequest httpRequest ) { 
String requestedWith = httpRequest . getHeader ( X_REQUESTED_WITH ) ; 
return requestedWith != null ? requestedWith . equalsIgnoreCase ( XML_HTTP_REQUEST ) : false ; 
} public static boolean isAndroid ( HttpServletRequest httpRequest ) { 
return requestedWith != null ? requestedWith . equalsIgnoreCase ( ANDROID_USER_AGENT ) : false ; 
return EMPTY_ARGUMENTS ; 
Closeable closeable = StreamFactory . getInstance ( inputStream , type ) ; 
threadLocal . set ( closeable ) ; 
return closeable ; 
public void persistInstance ( InstanceKey instanceKey , Object instance ) { 
instancesPool . put ( instanceKey , instance ) ; 
public void handle ( ElementEvent < TEntity > message ) { 
if ( message . getEndpoint ( ) . getEntityType ( ) == this . endpoint . getEntityType ( ) ) { 
refresh ( ) ; 
} @ SneakyThrows 
public static List < PropertyDescriptor > getProperties ( Class < ? > beanType ) { 
LinkedList < PropertyDescriptor > properties = new LinkedList < > ( ) ; 
for ( PropertyDescriptor property : Introspector . getBeanInfo ( beanType ) . getPropertyDescriptors ( ) ) { 
if ( getAnnotation ( beanType , property , Id . class ) . isPresent ( ) || property . getName ( ) . equals ( "name" ) ) { 
properties . addFirst ( property ) ; 
